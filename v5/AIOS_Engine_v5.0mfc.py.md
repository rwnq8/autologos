# AIOS_Engine_v5.0mfc.py (Minified, Functionally Comprehensive)
# Chunk 1: Core Engine Structure, Init, State Management, Logging
# Generated by LLM Orchestrator.  To be assembled by user.

import json as jsn, uuid as uid, datetime as dt, time as t

class A_MFC_v5: # AIOS_Minified_Functional_Comprehensive_v5
    def __init__(self, i_sjs=None): # i_sjs: initial_state_json_string
        self.lh = []  # log_history
        self.vF = "AIOS_Engine_v5.0mfc"  # engine_version_full
        self.vS = "5.0mfc"  # engine_version_short
        self.cM = "Sys"  # current_context_mh
        self.sV = "2.0mfc"  # state_schema_version
        self.kAS = None  # Kernel_ActiveCCO_JsonString
        self.kCI = None  # Kernel_CurrentMH_ID
        self.kMI = None  # Kernel_MH_Inputs_JsonString
        self.cco = None  # CCO_data (Python dict)
        # Internal MH state dictionaries (empty initially)
        self.s_ife = {} # IFE state
        self.s_pdf = {} # PDF state
        self.s_pln = {} # PLAN state
        self.s_cag = {} # CAG state
        self.s_tde = {} # TDE state
        self.s_sel = {} # SEL state
        self.s_kau = {} # KAU state
        self.s_fel = {} # FEL state
        self.s_mro = {} # MRO state

        self.lg("Sys", f"INIT: {self.vS} Started.")
        if i_sjs:
            try:
                self.is_(i_sjs) # import_state
                self.lg("Sys", f"INIT: State imported (schema {self.sV}).")
            except Exception as e:
                self.lg("Sys", f"ERR: State import failed: {e}. Using defaults.")
        else:
            self.lg("Sys", f"INIT: {self.vS} (default state).")
        self.lg("Sys", "INIT: Completed.")

    def exs(self):  # export_state
        self.lg("Sys", "EXS: Start")
        sd = { # State data
            "sV": self.sV, "vF": self.vF, "vS": self.vS, "cM": self.cM,
            "kAS": self.kAS, "kCI": self.kCI, "kMI": self.kMI, "cco": self.cco,
            "sIfe": self.s_ife, "sPdf": self.s_pdf, "sPl": self.sPl, "sCag": self.s_cag,
            "sTde": self.s_tde, "sSel": self.s_sel, "sKau": self.s_kau, "sFel": self.s_fel,
            "sMro": self.s_mro, "lh": self.lh
        }
        try: return jsn.dumps(sd)
        except TypeError as e:
            self.lg("Sys", f"ERR: EXS JSON fail: {e}")
            pk = [] # problematic_keys
            for k, v in sd.items():
                try: jsn.dumps({k: v})
                except: pk.append(k); sd[k] = f"UNS ({type(v).__name__})"
            self.lg("Sys", f"EXS: FB with {pk}")
            return jsn.dumps(sd)

    def is_(self, sjs):  # import_state, state_json_string -> sjs
        self.lg("Sys", "IS: Start")
        try: sd = jsn.loads(sjs)
        except jsn.JSONDecodeError as e: self.lg("Sys", f"ERR: IS JSON fail: {e}"); raise ValueError(f"IV_SJSON: {e}") from e
        isv = sd.get("sV")
        if isv != self.sV: self.lg("Sys", f"WARN: Schema mismatch. Engine: {self.sV}, Imp: {isv}")
        self.vF = sd.get("vF", self.vF); self.vS = sd.get("vS", self.vS); self.cM = sd.get("cM", "Sys")
        self.kAS = sd.get("kAS"); self.kCI = sd.get("kCI"); self.kMI = sd.get("kMI"); self.cco = sd.get("cco")
        self.s_ife = sd.get("sIfe", {}); self.s_pdf = sd.get("sPdf", {}); self.s_pln = sd.get("sPl", {})
        self.s_cag = sd.get("sCag", {}); self.s_tde = sd.get("sTde", {}); self.s_sel = sd.get("sSel", {})
        self.s_kau = sd.get("sKau", {}); self.s_fel = sd.get("sFel", {}); self.s_mro = sd.get("sMro", {})
        ilh = sd.get("lh", []) # imported log history
        self.lh = ilh if isinstance(ilh, list) else [f"LH_UNS:{type(ilh).__name__}"]; self.lg("Sys", "IS: Done")

    def _gt(self): return dt.datetime.now(dt.timezone.utc).isoformat() # _get_timestamp
    def lg(self, c, m): # aios_log (context, message)
        ts = self._gt(); vs = getattr(self, 'vS', 'unk'); fl = f"{ts} - LG ({c} v{vs}): {m}"; print(fl)
        if hasattr(self, 'lh') and isinstance(self.lh, list): self.lh.append(fl)
        else: print(f"F_LG_LH_ISSUE:{fl}"); self.lh = [f"LH_ISSUE@{ts}", fl] if not hasattr(self, 'lh') or not isinstance(self.lh, list) else self.lh.append(fl)

    # _cr: _create_llm_request
    def _cr(self, tt, pu=None, ctd=None, eid=None, ch=None, ccd=None): # tt: task_type, pu: prompt_to_user, ctd: cognitive_task_details, eid: expected_input_desc, ch: continuation_hint, ccd: cco_data_for_context
        r = {"rts": self._gts(), "evc": self.vF, "ccm": self.cM, "tt": tt} # r: request
        if pu: r["pu"] = pu
        if ctd: r["ctd"] = ctd
        if eid: r["eid"] = eid
        if ch: r["ch"] = ch
        cp = ccd if ccd is not None else self.cco # cp: current_cco_to_pass
        if cp:
            if isinstance(cp, dict): r["ccd"] = cp
            elif isinstance(cp, str):
                try: r["ccd"] = jsn.loads(cp)
                except: r["ccd"] = {"err": "CCO parse fail", "prev": cp[:100]}
        print(f"\n--- B_LLM_REQ ---"); print(jsn.dumps(r, indent=2)); print("--- E_LLM_REQ ---")
        return {"s": "A_LLM", "rd": r, "ces": self._ges()}

    def _ges(self): # _get_engine_state_snapshot
        s = {"kCI": self.kCI, "kMI": self.kMI, "kAS100": (self.kAS[:100] + "...") if self.kAS else None, "ccoId": self.cco.get('id', 'N/A') if isinstance(self.cco, dict) else 'N/A', "ccm_log": self.cM, "sV": self.sV}
        for dn in ['sIfe', 'sPdf', 'sPl', 'sCag', 'sTde', 'sSel', 'sKau', 'sFel', 'sMro']: # State keys
            d = getattr(self, dn, {});
            if d: s[f"{dn}Keys"] = list(d.keys())
        return s

    def pum(self, mt, mc): # PresentUserMessage_v3_0 (message_type, message_content)
        self.lg(self.cM, f"PUM: {mt}: {mc}"); return self._cr(tt="PUM", ctd={"mt": mt, "c": mc, "rmh": self.cM}, ch="Orch.present_message_to_user")

    def pco(self, jsi): # ParseJsonToCNLObject (json_string_input)
        if jsi is None or not isinstance(jsi, str) or jsi.strip() == "": self.lg(self.cM, "PCO: Null/empty input."); return None
        try: return jsn.loads(jsi)
        except jsn.JSONDecodeError as e: self.lg(self.cM, f"ERR: PCO JSON fail: {e}. Input: '{jsi[:50]}...'"); raise ValueError(f"JSON_PARSE_ERR: {e}") from e

    def cjo(self, coi): # ConvertCNLObjectToJson (cnl_object_input)
        if coi is None: return "null"
        try: return jsn.dumps(coi)
        except TypeError as e: self.lg(self.cM, f"ERR: CJO JSON fail: {e}"); raise ValueError(f"JSON_FORMAT_ERR: {e}") from e

    def lco(self, cco_d, let, msg, ado=None): # LogToCCOHistory_v3_0 (cco_data_dict, log_entry_type, message, associated_data)
        self.lg(self.cM, f"LCO: {let}: {msg}")
        if not isinstance(cco_d, dict): self.lg(self.cM, "LCO: CCO not a dict. Creating."); cco_d = {"olj": "[]"} # olj: operational_log_json
        oll = self.pco(cco_d.get("olj", "[]")); oll = [] if not isinstance(oll, list) else oll # Operational Log List
        nle = {"ts": self._gts(), "let": let, "lm": msg} # New Log Entry
        if ado is not None: nle["adj"] = self.cjo(ado) # Associated Data JSON
        oll.append(nle); cco_d["olj"] = self.cjo(oll); self.cco = cco_d; self.kAS = self.cjo(cco_d); return cco_d

    # --- Function Wrappers (for external function calls) ---
    def f_ipo(self, pu, ol): # fn_interaction_present_options_v3
        self.lg(self.cM, "fIPO")
        return self._cr(tt="UIR_PO", pu=pu, ctd={"o": ol, "it": "os"}, e="JSON {'s':'UC','c':<v>}", ch=f"A_MFC_v5().{self.cM.lower()}_pirc(r)") # Dynamic continuation based on current MH

    def f_iei(self, pu, hint=None, ch=None): # fn_interaction_elicit_user_input_v3
        self.lg(self.cM, "fIEI")
        ch = ch or f"A_MFC_v5().{self.cM.lower()}_s2(r)" # Default continuation to step 2 of current MH
        return self._cr(tt="UIR_ET", pu=pu, ctd={"it": "ft", "h": hint} if hint else {"it": "ft"}, e="JSON {'s':'UC','c':<txt>}", ch=ch)

    def f_gid(self, p): # fn_utility_generate_unique_id_v3 (prefix)
        self.lg(self.cM, f"fGID: {p}"); return {"s": "Gen", "uid": f"{p}{uid.uuid4()}"}

    def f_dts(self, i, cx, dlh, rgh, okn="dtxt"): # fn_content_draft_text_segment_v3
        self.lg(self.cM, f"fDTS: {okn}")
        return self._cr(tt="CT_DDT", ctd={"tsn": "cDTS", "i": i, "cx": cx, "dlh": dlh, "rgh": rgh, "ofg": f"JSON {{'{okn}':'','s':'DraftComplete'}}"}, e=f"JSON {{'{okn}':'<txt>','s':'DraftComplete'}}", ch=f"A_MFC_v5().{self.cM.lower()}_s_cdt(r)", ccd=self.cco)

    def f_ucs(self, cco_d, sp, ncj): # fn_data_update_cco_section_v3
        self.lg(self.cM, f"fUCS: Path: {sp}")
        if not isinstance(cco_d, dict): self.lg(self.cM, "fUCS: CCO not dict."); return cco_d
        ks = sp.split('.'); cl = cco_d # Current level
        try:
            for i, k in enumerate(ks):
                if i == len(ks) - 1: cl[k] = ncj
                else:
                    if k not in cl or not isinstance(cl[k], dict): cl[k] = {}
                    cl = cl[k]
            self.cco = cco_d; self.kAS = self.cjo(cco_d); return cco_d
        except Exception as ex: self.lg(self.cM, f"ERR: fUCS '{sp}': {ex}"); return cco_d

    def f_mrp(self, dcjs, rgo, ccjs, cmc, cch): # fn_mro_RefineOutput_Pipeline_v3_0
        self.lg(self.cM, f"fMRP: {cmc}")
        return self.mro_s1i(dcjs, self.cjo(rgo), ccjs, cmc, cch)

    def f_iud(self, uit): # fn_interpret_user_directive_for_next_mh_v3
        self.lg(self.cM, f"fIUD: {uit}")
        l = uit.lower().strip(); nid = "AUI"; ni = {}; upm = "Cmd not understood. What next?"
        if any(x == l for x in ["new process", "1", "1."]): nid = "IFE"; upm = None
        elif any(x == l for x in ["evolve engine", "2", "2."]): nid = "FEL"; upm = None
        elif any(x == l for x in ["terminate aios", "terminate", "exit", "quit", "3", "3."]): nid = "TA"; upm = None
        elif "define problem" in l or "pdf" in l: nid = "PDF"; upm = None
        elif "create plan" in l or "plan" in l: nid = "PLN"; upm = None
        elif "execute plan" in l or "run tasks" in l or "tde" in l: nid = "TDE"; upm = None
        elif "explore solutions" in l or "sel" in l: nid = "SEL"; upm = None
        elif "update knowledge" in l or "kau" in l or "learn" in l: nid = "KAU"; upm = None
        r = {"s": "OK" if nid != "AUI" else "Clarify", "nid": nid, "nijs": self.cjo(ni)};
        if upm: r["upm"] = upm
        return r

    def f_qacr(self, ccjs, ccf): self.lg(self.cM, f"MRO: Req Adaptive Crit Rules. Focus: {ccf}"); return self._cr(tt="CT_MRO_QACR", ctd={"ccj": ccjs, "ccf": ccf, "ofg": "JSON {'r':[]}"}, e="JSON {'r':[]}", ch="A_MFC_v5().mro_cacr(r)")
    def f_acc(self, ctcr, ccr, cx, ar): self.lg(self.cM, "MRO: Req Crit Content Analysis"); return self._cr(tt="CT_MRO_ACC", ctd={"ctcj": ctcr, "ccj": ccr, "cxj": cx, "arj": ar, "ofg": "JSON quality report"}, e="JSON quality report", ch="A_MFC_v5().mro_cacc(r)")
    def f_uvds(self, doj, sn): self.lg(self.cM, f"MRO: Req Schema Val. Schema: {sn}"); return self._cr(tt="CT_MRO_VS", ctd={"doj": doj, "sn": sn, "ofg": "JSON {'iv':True/False,'e':'...'}"}, e="JSON {'iv':True/False,'e':'...'}", ch="A_MFC_v5().mro_cav(r)")
    def f_asc(self, rcr, sgj): self.lg(self.cM, "MRO: Req Synth Crit"); return self._cr(tt="CT_MRO_SC", ctd={"rcr": rcr, "sgj": sgj, "ofg": "JSON synth crit summ"}, e="JSON synth crit summ", ch="A_MFC_v5().mro_casc(r)")
    def f_csr(self, ccj, scj, cxj): self.lg(self.cM, "MRO: Req Content Rev Sugg"); return self._cr(tt="CT_MRO_CSR", ctd={"ccj": ccj, "scj": scj, "cxj": cxj, "ofg": "JSON rev sugg"}, e="JSON rev sugg", ch="A_MFC_v5().mro_casr(r)")
    def f_car(self, ccj, ri, cxj): self.lg(self.cM, "MRO: Req Content Apply Revs"); return self._cr(tt="CT_MRO_CAR", ctd={"ccj": ccj, "rij": ri, "cxj": cxj, "ofg": "JSON rev content"}, e="JSON rev content", ch="A_MFC_v5().mro_caar(r)")
    def f_acv(self, cv1, cv2, ct): self.lg(self.cM, "MRO: Req Content Ver Comp"); return self._cr(tt="CT_MRO_ACV", ctd={"cv1j": cv1, "cv2j": cv2, "ctj": ct, "ofg": "JSON comp res"}, e="JSON comp res", ch="A_MFC_v5().mro_cacv(r)")
    def f_fcnv(self, cer): self.lg(self.cM, "FEL: Req Calc Next Ver"); return self._cr(tt="CT_FEL_CNV", ctd={"cer": cer, "ofg": "JSON {'nvs':'x.y.z','s':'OK'}"}, e="JSON {'nvs':'...', 's':'OK'}", ch="A_MFC_v5().fel_s4pv(r)")
    def f_flt(self, tsd): self.lg(self.cM, "FEL: Req Load TIDs"); return self._cr(tt="CT_FEL_LT", ctd={"tsd": tsd, "ofg": "JSON {'tl':[],'s':'OK'}"}, e="JSON {'tids_loaded':[],'s':'OK'}", ch="A_MFC_v5().fel_s3pt(r)")
    def f_fatem(self, cem, tta): self.lg(self.cM, "FEL: Req Apply TIDs to Model"); return self._cr(tt="CT_FEL_ATEM", ctd={"cem": cem, "tta": tta, "ofg": "JSON {'eem':{},'al':'...','s':'OK'}"}, e="JSON {'eem':{},'al':'...','s':'OK'}", ch="A_MFC_v5().fel_s5pat(r)")
    def f_urea(self, eem, tf="py"): self.lg(self.cM, f"FEL: Req Regen Artefact. Fmt: {tf}"); return self._cr(tt="CT_FEL_UREA", ctd={"eem": eem, "tf": tf, "ofg": "JSON {'eat':'<txt>','clt':'...','s':'OK'}"}, e="JSON {'eat':'<txt>','clt':'...','s':'OK'}", ch="A_MFC_v5().fel_s6f(r)")
    def f_aled(self, dta, lf, cco_): self.lg(self.cM, "KAU: Req Extract Learns"); return self._cr(tt="CT_KAU_ALED", ctd={"dta": dta, "lf": lf, "cco": cco_, "ofg": "JSON {'l':[]}"}, e="JSON {'learnings':[{'type':'...','statement':'...'}],'s':'OK'}", ch="A_MFC_v5().kau_s2pl(r)")
    def f_agso(self, pc, cco_): self.lg(self.cM, "SEL: Req Gen SolOpts"); return self._cr(tt="CT_SEL_AGSO", ctd={"pc": pc, "cco": cco_, "ofg": "JSON {'so':[]}"}, e="JSON {'solution_options':[{'id':'...','desc':'...'}],'s':'OK'}", ch="A_MFC_v5().sel_s2pgo(r)")
    def f_aeso(self, so, ec, cco_): self.lg(self.cM, "SEL: Req Eval SolOpt"); return self._cr(tt="CT_SEL_AESO", ctd={"so": so, "ec": ec, "cco": cco_, "ofg": "JSON {'oid':'','es':{},'sum':''}"}, e="JSON {'oid':'','es':{},'sum':'','s':'OK'}", ch="A_MFC_v5().sel_sper(r)")
    def f_adp(self, ps, cco_): self.lg(self.cM, "PDF: Req Decomp Prob"); return self._cr(tt="CT_PDF_ADP", ctd={"ps": ps, "cco": cco_, "ofg": "JSON {'dd':{}}"}, e="JSON {'decomposition_details':{...},'s':'OK'}", ch="A_MFC_v5().pdf_s3pd(r)")
    def f_pcp(self, pd, cco_): self.lg(self.cM, "PLN: Req Create Phases"); return self._cr(tt="CT_PLN_PCP", ctd={"pd": pd, "cco": cco_, "ofg": "JSON {'phs':[]}"}, e="JSON {'phases':[{'id':'...','name':'...'}],'s':'OK'}", ch="A_MFC_v5().pln_s2pp(r)")
    def f_pct(self, ph, pd, cco_): self.lg(self.cM, f"PLN: Req Create Tasks for Phase: {ph.get('id')}"); return self._cr(tt="CT_PLN_PCT", ctd={"ph": ph, "pd": pd, "cco": cco_, "ofg": "JSON {'tsks':[]}"}, e="JSON {'tasks':[{'id':'...','name':'...'}],'s':'OK'}", ch="A_MFC_v5().pln_spt(r)")


# AIOS_Engine_v5.0mfc.py (Chunk 3: Kernel Methods)
# Assumes Chunk 1 and Chunk 2 have been correctly pasted into the file by the user.

    def k_st(self, sjs=None):  # kernel_start (initial_state_json_string)
        if sjs:
            try:
                self.is_(sjs)
                self.lg("K", f"RESTART: From state (MH: {self.kCI}).")
                if self.kCI and self.kCI != "AUI": return self.k_rcmh() # Resume previous MH
                else: return self.k_pio()  # Or present initial options if no active MH
            except Exception as e:
                self.lg("K", f"ERR: State import fail in k_st: {e}. Starting fresh.")
                self._ids() # Re-initialize defaults
                self.cM = "K"; self.lg("K", f"{self.vF} starting (post-import-error).")
                self.pum("Status", f"{self.vF} Init. Ready."); res = self.k_pio(); self.lg("K", "START: Done (post-error)."); return res
        # Fresh session start
        self.cM = "K"; self.lg("K", f"{self.vF} starting.")
        self.pum("Status", f"{self.vF} Init. Ready."); res = self.k_pio(); self.lg("K", "START: Done."); return res

    def k_pio(self): # kernel_present_initial_options
        self.cM = "K"; self.lg(self.cM, "PIO: Presenting init opts.")
        opts = [{"v": "NP", "l": "1. New Process"}, {"v": "EE", "l": "2. Evolve Engine"}, {"v": "TA", "l": "3. Terminate"}]
        return self.f_ipo(pu=f"AIOS v{self.vS} Ready. How to begin?", ol=opts)

    def k_pirc(self, llr): # kernel_process_initial_choice_result (llm_response)
        self.cM = "K"
        if not llr or not isinstance(llr, dict) or llr.get("s") != "UC":
            self.lg(self.cM, "Invalid initial choice result. Reprompting.")
            self.pum("Warning", "Invalid choice. Retry.")
            return self.k_pio()
        
        cmd = llr.get("c")
        self.lg(self.cM, f"Processing initial choice: '{cmd}'")
        ir = self.f_iud(cmd) # Interpret user directive
        self.kCI = ir.get("nid"); self.kMI = ir.get("nijs")
        if self.kCI == "TA":
            self.pum("Status", "AIOS termination initiated.")
            return {"s": "TERM_REQ", "fes": self._ges()}
        elif self.kCI and self.kCI != "AUI": self.lg(self.cM, f"Kernel: Next MH: {self.kCI}"); return self.k_rcmh()
        else: self.pum("Warning", ir.get("upm", f"Unrecognized choice: '{cmd}'.")); return self.k_pio()

    def k_rcmh(self): # kernel_run_current_mh
        self.cM = "K"
        if self.kCI == "TA": self.pum("Status", "AIOS terminated."); return {"s": "TERM", "fes": self._ges()}
        elif self.kCI == "AUI" or not self.kCI: self.lg(self.cM, "Kernel paused."); return self._cr(tt="UIR_GD", pu="AIOS paused. What next?", e="User's command.", ch="A_MFC_v5().k_pgud(r)")
        self.lg(self.cM, f"Kernel: Executing MH: {self.kCI}"); self.pum("Status", f"Executing MH: {self.kCI}")
        mi = self.pco(self.kMI) # mh_inputs
        # Mapping of MH IDs to their start methods
        mh_map = {"IFE": self.ife_s1, "PDF": self.pdf_s1, "PLN": self.pln_s1, "TDE": self.tde_s1, "CAG": self.cag_s1, "SEL": self.sel_s1, "KAU": self.kau_s1, "FEL": self.fel_s1i}
        if self.kCI in mh_map: return mh_map[self.kCI](mi)
        else: self.lg(self.cM, f"ERR: MH '{self.kCI}' not impl."); self.pum("Error", f"MH '{self.kCI}' not available."); self.kCI = "AUI"; return self.k_rcmh()

    def k_pmr(self, mjid, mhr): # kernel_process_mh_result (mh_that_just_ran_id, mh_result)
        self.cM = "K"; s = mhr.get("s"); self.lg(self.cM, f"Processing result from '{mjid}'. Status: '{s}'")
        if not mhr or not isinstance(mhr, dict): self.pum("Error", f"Invalid result from '{mjid}'."); self.kCI = "AUI"; return self.k_rcmh()
        if s == "MRO_PIPELINE_COMPLETE": # Simplified status
            self.lg(self.cM, f"MRO complete. Return to {mhr.get('cmc')} at {mhr.get('cch')}")
            cmn = mhr.get("cch"); # continuation_method_name
            if cmn and hasattr(self, cmn.split('.')[-1]): return getattr(self, cmn.split('.')[-1])(mhr)
            else: self.lg(self.cM, f"ERR: Invalid MRO cont hint: '{cmn}'"); self.kCI = "AUI"; return self.k_rcmh()
        if "uccoj" in mhr: self.kAS = mhr["uccoj"]; self.cco = self.pco(self.kAS); self.lg(self.cM, f"CCO updated by '{mjid}'.")
        elif self.cco is not None: self.kAS = self.cjo(self.cco)
        if s == "A_LLM": self.lg(self.cM, f"'{mjid}' awaits LLM for: {mhr.get('rd',{}).get('tt')}"); return mhr
        ld = mhr.get("dfl") # log details
        if self.cco is None: self.cco = {"olj": "[]", "id": f"kcco_{uid.uuid4().hex[:4]}"}; self.kAS = self.cjo(self.cco); self.lg(self.cM, "Init minimal CCO for MH_C.")
        self.cco = self.lco(self.cco, "MH_C", f"{mjid} s: {s}.", ld)
        if "Error" in s or "Failed" in s: self.pum("Error", f"MH {mjid} issue: {s}.")
        else: self.pum("Status", f"{mjid} completed with status: {s}.")
        nMH = "AUI"; ni = {} # next_mh, next_inputs
        if mjid == "IFE" and "Complete" in s: nMH = "PDF"
        elif mjid == "PDF" and "Complete" in s: nMH = "PLN"
        elif mjid == "PLN" and "Complete" in s: nMH = "TDE"
        elif mjid == "TDE" and "AllTasksComplete" in s: nMH = "KAU"
        elif mjid == "CAG" and "UserReview" in s: nMH = "AUI"
        elif mjid == "SEL" and "Complete" in s: nMH = "KAU"
        elif mjid == "KAU" and "Complete" in s: nMH = "AUI"
        elif mjid == "FEL" and "FEL_EvolutionProposed_Complete" in s: nMH = "TA"
        self.kCI = nMH; self.kMI = self.cjo(ni)
        if "Complete" in s and nMH != "TA" and self.cco: self.pum("Suggestion", "Significant work completed. Consider saving CCO state.")
        return self.k_rcmh()

    def k_pgud(self, llr): # kernel_process_general_user_directive
        self.cM = "K"; udt = llr.get("command", ""); self.lg(self.cM, f"Processing general directive: '{udt}'")
        ir = self.f_iud(udt) # Interpret user directive
        self.kCI = ir.get("nid", "AUI"); self.kMI = ir.get("nijs", "{}")
        if self.kCI == "AUI" and ir.get("upm"): return self._cr(tt="UIR_GD", pu=ir.get("upm"), ch="A_MFC_v5().k_pgud(r)")
        return self.k_rcmh()

    # --- Meta-Handler (MH) Methods ---
    def ife_s1(self, a): # IFE-MH Step 1 (get_core_idea)
        self.cM = "IFE"; self.sI = {}; self.lg(self.cM, "S1: Start")
        self.pum("Status", f"IFE (v{self.vS}): Starting...")
        self.sI["u_ptfk"] = a.get("uip") if a else None # user_prompt_text_from_kernel
        self.sI["cco_jfk"] = a.get("eccojir") if a else self.kAS # existing_cco_json_if_reexploring
        self.cco = self.pco(self.sI["cco_jfk"]) if self.sI["cco_jfk"] else None
        if self.sI["u_ptfk"]:
            self.lg(self.cM, "Core idea from Kernel.")
            llr = {"s": "UC", "c": self.sI["u_ptfk"], "ut": self.sI["u_ptfk"]} # Simulate user command with prompt text
            return self.ife_s2(llr) # Proceed to process core idea
        else:
            self.lg(self.cM, "Eliciting core idea.")
            return self.f_iei(pu="What's the core idea/problem?", ch=f"A_MFC_v5().{self.cM.lower()}_s2(r)")

    def ife_s2(self, llr): # IFE-MH Step 2 (process_core_idea)
        self.cM = "IFE"
        upt = llr.get("c") # user_provided_text
        self.lg(self.cM, f"S2: Core idea: '{upt}'")
        if not upt:
            self.pum("Error", "No core idea provided.")
            return self.k_pmr(mjid="IFE", mhr={"s": "IFE_Failed_NoCoreIdea", "uccoj": self.cjo(self.cco)})
        self.sI["uci"] = upt
        if self.cco is None:
            self.lg(self.cM, "Init new CCO.")
            id_res = self.f_gid("cco_"); new_cco_id = id_res.get("uid")
            prompt_summ = self.sI["uci"][:47] + "..." if len(self.sI["uci"]) > 50 else self.sI["uci"]
            self.cco = {"id": new_cco_id, "pid": None, "md": {"nl": f"CCO for: {prompt_summ}", "cf": "IFE", "svu": f"v{self.sV}", "evc": self.vF, "ucdc": self._gts(), "tk": self.sI["uci"].split()[:3], "cpi": "IFE_A", "phj": "[]"}, "cej": "null", "idsj": jsn.dumps({"up": self.sI["uci"]}), "kaj": jsn.dumps({"ca": []}), "olj": "[]", "plnj": "null", "pcdj": "null", "eldj": "null", "adj": "null", "osj": "null"}
            self.cco = self.lco(self.cco, let="IFE_EVT", msg="New CCO init.", ado={"nid": new_cco_id})
            self.pum("Info", f"New CCO {new_cco_id} created.")
        else:
            self.lg(self.cM, f"Using existing CCO: {self.cco.get('id', 'N/A')}")
            self.cco = self.lco(self.cco, let="IFE_EVT", msg=f"Processing idea: '{self.sI['uci']}'", ado={"p": self.sI['uci']})
        self.kAS = self.cjo(self.cco)
        self.lg(self.cM, "Req LLM to draft core essence.")
        dc = {"upi": self.sI["uci"], "cco_id": self.cco.get("id"), "cpi": self.cco.get("md", {}).get("cpi"), "eg": f"Focus on TP. Adhere to {self.vS}."} # draft_context
        return self.f_dts(i="Draft 'cet'.", cx=dc, dlh="1-3 sent", rgh="summ_insp_def_ce", okn="cet", ch=f"A_MFC_v5().ife_s3(r)")

    def ife_s3(self, llr): # IFE-MH Step 3 (process_essence_draft)
        self.cM = "IFE"; self.lg(self.cM, "S3: Received LLM draft for core essence.")
        if not llr or llr.get("s") != "DraftComplete" or not llr.get("cet"):
            self.pum("Error", "Invalid core essence draft. Placeholder.")
            llr = {"cet": "Placeholder essence.", "s": "ErrFall_Draft"}
        self.sI["dejs_mro"] = self.cjo(llr) # drafted_essence_json_str_for_mro
        self.lg(self.cM, "Req LLM to refine core essence (MRO).")
        rgo = {"qcj": self.cjo({f"AIOS_v{self.vS}_TVNF": True, f"AIOS_v{self.vS}_IDCF": True, "CI": True, "TPF": "Core Essence"}), "cfh": "Maximize Transformative Value", "rsv": False}
        return self.f_mrp(dcjs=self.sI["dejs_mro"], rgo=rgo, ccjs=self.cjo(self.cco), cmc="IFE", cch="A_MFC_v5().ife_s4(r)")

    def ife_s4(self, mro_res): # IFE-MH Step 4 (finalize_essence)
        self.cM = "IFE"; mr = mro_res.get("mro_result", {}); self.lg(self.cM, f"S4: Received MRO result. Status: {mr.get('s')}")
        if not mr or mr.get("s") not in ["Success_Converged", "Success_MaxIterationsReached"] or not mr.get("roj"):
            self.pum("Warning", "MRO didn't refine. Using pre-MRO draft.")
            self.sI["rejs_cco"] = mr.get("roj", self.sI.get("dejs_mro", self.cjo({"cet": "MRO Error"})))
        else: self.sI["rejs_cco"] = mr.get("roj")
        self.cco = self.f_ucs(self.cco, "cej", self.sI["rejs_cco"]) # core_essence_json -> cej
        self.cco = self.lco(self.cco, "IFE_EVT", f"Core essence finalized. MRO Status: {mr.get('s', 'N/A')}", self.pco(self.sI["rejs_cco"]))
        self.lg(self.cM, "Concluded successfully."); self.pum("Status", "IFE: Idea Exploration complete.")
        final_res = {"s": "IFE_Complete", "uccoj": self.cjo(self.cco), "dfl": {"summary": f"IFE finished for CCO ID: {self.cco.get('id', 'N/A')}"}}
        return self.k_pmr("IFE", final_res)

    def pdf_s1(self, mi): # PDF-MH Step 1 (initialize)
        self.cM = "PDF"; self.sP = {}; self.lg(self.cM, "S1: Start"); self.pum("Status", "PDF: Starting...")
        if not self.cco or not self.pco(self.cco.get("cej")): self.pum("Error", "PDF: Missing CCO or essence."); return self.k_pmr("PDF", {"s": "PDF_ERR_NO_ESSENCE"})
        self.sP["ceo"] = self.pco(self.cco.get("cej"))
        self.pum("Info", f"PDF: Reviewing core essence: {self.sP['ceo']}")
        return self.f_iei(pu="PDF: Further details/constraints?", ch=f"A_MFC_v5().pdf_s2(r)")

    def pdf_s2(self, llr): # PDF-MH Step 2 (process_details)
        self.cM = "PDF"; ud = llr.get("c"); self.sP["ud"] = ud # user_details
        self.lg(self.cM, f"S2: Received details: {ud}")
        self.cco = self.lco(self.cco, "PDF_DETAILS", "User provided details.", {"details": ud})
        psfa = f"Core Idea: {self.sP['ceo'].get('cet', '')}\nDetails: {ud}" # problem_statement_for_analysis
        return self.f_adp(psfa, self.cco)

    def pdf_s3pd(self, llr): # PDF-MH Step 3 (process_decomposition) - renamed for clarity
        self.cM = "PDF"; self.lg(self.cM, f"S3: Received decomposition: {llr}")
        dd = llr.get("dd", llr) # decomposition_details
        self.sP["dd"] = dd
        ka = self.pco(self.cco.get("kaj", "{}")) # knowledge_artifacts
        ka["pdd"] = self.sP["dd"] # problem_definition_and_decomposition
        self.cco = self.f_ucs(self.cco, "kaj", self.cjo(ka))
        self.cco = self.lco(self.cco, "PDF_RESULT", "Problem decomposition stored.", self.sP["dd"])
        self.pum("Info", "PDF: Problem decomposition complete.")
        return self.k_pmr("PDF", {"s": "PDF_Complete", "uccoj": self.cjo(self.cco)})

    def pln_s1(self, mi): # PLAN-MH Step 1 (initialize)
        self.cM = "PLN"; self.sPl = {}; self.lg(self.cM, "S1: Start"); self.pum("Status", "PLAN: Starting...")
        if not self.cco: self.pum("Error", "PLAN: Missing CCO."); return self.k_pmr("PLN", {"s": "PLN_ERR_NO_CCO"})
        ka = self.pco(self.cco.get("kaj", "{}"))
        self.sPl["pd"] = ka.get("pdd", {"ps": "Problem not defined."}) # problem_definition
        self.pum("Info", f"PLAN: Using problem definition: {self.sPl['pd']}")
        return self.f_pcp(self.sPl["pd"], self.cco)

    def pln_s2pp(self, llr): # PLAN-MH Step 2 (process_phases)
        self.cM = "PLN"; self.lg(self.cM, f"S2: Received phases: {llr}")
        phs = llr.get("phs", []) # phases
        if not phs: self.pum("Warning", "PLAN: No phases generated."); return self.k_pmr("PLN", {"s": "PLN_ERR_NO_PHS"})
        self.sPl["phs"] = phs
        self.sPl["po"] = {"phs": self.sPl["phs"], "tbp": {}} # plan_object, tasks_by_phase
        self.sPl["cpi"] = 0 # current_phase_index
        self.cco = self.lco(self.cco, "PLN_PHASES", "Plan phases created.", {"phs": phs})
        return self._pln_pnt() # Proceed to generate tasks

    def _pln_pnt(self): # _plan_process_next_phase_tasks
        self.cM = "PLN"
        if self.sPl["cpi"] >= len(self.sPl["phs"]): return self.pln_s3fp() # All phases processed
        cp = self.sPl["phs"][self.sPl["cpi"]] # current_phase
        self.lg(self.cM, f"Req tasks for phase: {cp.get('id')} - {cp.get('name')}")
        return self.f_pct(ph=cp, pd=self.sPl["pd"], cco_=self.cco)

    def pln_spt(self, llr): # PLAN-MH Step 3 (process_tasks)
        self.cM = "PLN"; cpi = self.sPl["cpi"]; cpid = self.sPl["phs"][cpi].get("id") # current_phase_id
        self.lg(self.cM, f"Rcvd tasks for phase {cpid}: {llr}")
        tsks = llr.get("tsks", []) # tasks
        self.sPl["po"]["tbp"][cpid] = tsks
        self.cco = self.lco(self.cco, let="PLN_TASKS", msg=f"Tasks for {cpid} created.", ado={"pid": cpid, "tc": len(tsks)})
        self.sPl["cpi"] += 1
        return self._pln_pnt()

    def pln_s3fp(self): # plan_step3_finalize_plan
        self.cM = "PLN"; self.lg(self.cM, "All phases proc. Finalizing.")
        pjs = self.cjo(self.sPl["po"]); self.cco = self.f_ucs(self.cco, "psj", pjs) # plan_structured_json -> psj
        self.cco = self.lco(self.cco, let="PLN_FINAL", msg="Plan finalized.", ado=self.sPl["po"])
        self.pum("Info", "PLAN: Plan generation complete.")
        return self.k_pmr("PLN", {"s": "PLAN_Complete", "uccoj": self.cjo(self.cco)})

    def tde_s1(self, mi): # TDE-MH Step 1 (initialize)
        self.cM = "TDE"; self.sT = {}; self.lg(self.cM, "S1: Start"); self.pum("Status", "TDE: Starting...")
        if not self.cco or not self.cco.get("psj") or self.cco.get("psj") == "null": self.pum("Error", "TDE: Missing CCO or plan."); return self.k_pmr("TDE", {"s": "TDE_ERR_NO_PLAN"})
        self.sT["plan"] = self.pco(self.cco.get("psj"))
        if not self.sT["plan"] or not self.sT["plan"].get("phs"): self.pum("Error", "TDE: Invalid plan."); return self.k_pmr("TDE", {"s": "TDE_ERR_INV_PLAN"})
        self.sT["cpi"] = 0; self.sT["ctip"] = 0 # current_phase_index, current_task_index_in_phase
        self.pum("Info", f"TDE: Loaded plan ({len(self.sT['plan']['phs'])} phases).")
        self.cco = self.lco(self.cco, let="TDE_START", msg=f"Plan loaded ({len(self.sT['plan']['phs'])} phases).", ado={"phase_count": len(self.sT['plan']['phs'])})
        return self._tde_pnt() # Proceed to process next task

    def _tde_pnt(self): # _tde_process_next_task
        self.cM = "TDE"; s = self.sT
        if s["cpi"] >= len(s["plan"]["phs"]): self.lg(self.cM, "All phases processed."); return self._tde_fin()
        cp = s["plan"]["phs"][s["cpi"]]; cpi = cp.get("id"); tsks = s["plan"]["tbp"].get(cpi, []) # current_phase, current_phase_id, tasks
        if s["ctip"] >= len(tsks): self.lg(self.cM, f"Phase {cpi} complete."); s["cpi"] += 1; s["ctip"] = 0; return self._tde_pnt()
        ct = tsks[s["ctip"]]; self.lg(self.cM, f"Dispatching task: {ct.get('id')} - {ct.get('name')}"); self.pum("Info", f"TDE: Starting '{ct.get('name')}'") # current_task
        tt = ct.get("type", "unknown").lower(); mhs = ct.get("assigned_mh_suggestion", "").upper() # task_type, mh_suggestion
        if mhs == "CAG" or "draft" in tt: self.kCI = "CAG"; self.kMI = self.cjo({"task_details": ct, "ccoj": self.kAS}); return self.k_rcmh()
        elif mhs == "SEL" or "solution" in tt or "explore" in tt: self.kCI = "SEL"; self.kMI = self.cjo({"task_details": ct, "ccoj": self.kAS}); return self.k_rcmh()
        elif mhs == "KAU" or "learn" in tt: self.kCI = "KAU"; self.kMI = self.cjo({"task_details": ct, "ccoj": self.kAS}); return self.k_rcmh()
        # Add dispatch for other MHs here (PDF, PLAN, etc.) if they can be sub-tasks of TDE
        else:
            self.lg(self.cM, f"Task '{ct.get('name')}' (type: {tt}, MH suggestion: {mhs}) requires direct LLM action or other handling.")
            # For now, simulate execution and proceed to next task
            self.pum("Info", f"TDE: Task '{ct.get('name')}' execution simulated.")
            s["ctip"] += 1; return self._tde_pnt()

    def _tde_fin(self): # _tde_finalize_execution
        self.cM = "TDE"; self.lg(self.cM, "All tasks executed.")
        self.pum("Status", "TDE: All planned tasks processed.")
        return self.k_pmr("TDE", {"s": "TDE_AllTasksComplete", "uccoj": self.cjo(self.cco)})

    def cag_s1(self, mi): # CAG-MH Step 1 (prepare)
        self.cM = "CAG"; self.sCg = {}; self.lg(self.cM, "S1: Start"); self.pum("Status", f"CAG (v{self.vS}): Starting...")
        ccojs = mi.get("ccoj", self.kAS) # cco_json_str
        self.cco = self.pco(ccojs)
        if not self.cco or not self.pco(self.cco.get("cej")):
            self.pum("Error", "CAG: Missing CCO or core essence.")
            return self.k_pmr("CAG", {"s": "CAG_ERR_MISSING_ESSENCE", "uccoj": self.cjo(self.cco)})
        ceo = self.pco(self.cco.get("cej", "{}")) # core_essence_obj
        cets = ceo.get("cet", "The core idea.") # core_essence_text
        self.pum("Info", f"CAG: Drafting based on essence: '{cets}'")
        dc = {"ces": cets, "ccoid": self.cco.get("id"), "ca": self.pco(self.cco.get("kaj", "{}")).get("ca", []), "tdp": "Intro"} # draft_context
        di = f"Draft intro based on core essence. {self.vS} principles. Integrate anchors if relevant." # draft_instructions
        return self.f_dts(i=di, cx=dc, dlh="1-2 para", rgh="intro_overview", okn="sdt", ch=f"A_MFC_v5().cag_s2(r)")

    def cag_s2(self, llr): # CAG-MH Step 2 (process_draft)
        self.cM = "CAG"; self.lg(self.cM, "S2: Received LLM draft.")
        if not llr or llr.get("s") != "DraftComplete" or not llr.get("sdt"):
            self.pum("Error", "CAG: Invalid draft. Placeholder.")
            llr = {"sdt": "Placeholder section.", "s": "ErrFall_Draft"}
        txt = llr.get("sdt"); self.sCg["djs_mro"] = self.cjo({"txt": txt}) # draft_json_str_for_mro
        self.lg(self.cM, "Req MRO refinement.")
        rgo = {"tpfd": "Intro Section", "qcj": self.cjo({f"AIOS_v{self.vS}_TVNF": True, f"AIOS_v{self.vS}_IDCE": True, "ClarityAndEngagement": True, "LF": True}), "cfh": "Refine for narrative and insight."}
        return self.f_mrp(dcjs=self.sCg["djs_mro"], rgo=rgo, ccjs=self.cjo(self.cco), cmc="CAG", cch="A_MFC_v5().cag_s3(r)")

    def cag_s3(self, mro_res): # CAG-MH Step 3 (finalize_draft)
        self.cM = "CAG"; mr = mro_res.get("mro_result", {}); self.lg(self.cM, f"S3: Received MRO result. Status: {mr.get('s')}")
        if not mr or mr.get("s") not in ["Success_Converged", "Success_MaxIterationsReached"] or not mr.get("roj"):
            self.pum("Warning", "CAG: MRO didn't refine. Using pre-MRO draft.")
            rsec_cjs = self.sCg.get("djs_mro", self.cjo({"txt": "MRO Error"})) # refined_section_content_json_str
        else: rsec_cjs = mr.get("roj")
        pdd = self.pco(self.cco.get("pcdj", "{}")) # product_data_dict, product_content_data_json -> pcdj
        if not isinstance(pdd, dict): pdd = {}
        if "ds" not in pdd or not isinstance(pdd["ds"], list): pdd["ds"] = [] # document_sections -> ds
        nse = {"st": "Intro (Draft 1)", "cdjs": rsec_cjs, "mrsj": mr.get("rsj")} # new_section_entry, section_title, content_details_json_str, mro_refinement_summary_json_str
        pdd["ds"].append(nse)
        self.cco = self.f_ucs(self.cco, "pcdj", self.cjo(pdd))
        self.cco = self.lco(self.cco, "CAG_EVT", "Intro drafted & refined.", self.pco(rsec_cjs))
        self.pum("Status", "CAG: Intro draft complete.")
        rt = self.pco(rsec_cjs); ftxt = rt.get("txt", "Error displaying draft.") # refined_text, final_text
        self.pum("DraftOutput", {"title": "Draft Intro", "content": ftxt, "notes": f"MRO for {self.vS}"})
        return self.k_pmr("CAG", {"s": "CAG_DraftComplete_UserReview", "uccoj": self.cjo(self.cco), "dfl": {"summary": f"CAG draft complete for CCO ID: {self.cco.get('id', 'N/A')}" }})

    def sel_s1(self, mi): # SEL-MH Step 1 (initialize)
        self.cM = "SEL"; self.sSl = {}; self.lg(self.cM, "S1: Start"); self.pum("Status", "SEL: Starting...")
        if "ccoj" in mi: # If cco_json is provided in input
            self.cco = self.pco(mi["ccoj"]); self.kAS = mi["ccoj"]
        pc = mi.get("pc") # problem_context
        if pc: self.sSl["pc"] = pc
        elif self.cco:
            ka = self.pco(self.cco.get("kaj", "{}")) # knowledge_artifacts
            self.sSl["pc"] = ka.get("pdd") # problem_definition_and_decomposition
        if not self.sSl.get("pc"): self.pum("Error", "SEL: Missing problem context."); return self.k_pmr("SEL", {"s": "SEL_ERR_NO_CONTEXT", "uccoj": self.cjo(self.cco)})
        return self.f_agso(self.sSl["pc"], self.cco)

    def sel_s2pgo(self, llr): # SEL-MH Step 2 (process_generated_options)
        self.cM = "SEL"; self.sSl["so"] = llr.get("so", []) # solution_options
        if not self.sSl["so"]: self.pum("Warning", "SEL: No options generated."); return self.k_pmr("SEL", {"s": "SEL_NoOpts"})
        self.pum("Info", f"SEL: Generated {len(self.sSl['so'])} options.")
        self.sSl["ec"] = {"criteria": ["feasibility", "impact", "effort", "alignment"]} # evaluation_criteria
        self.sSl["eo"] = []; self.sSl["coi"] = 0 # evaluated_options, current_option_index
        return self._sel_eno() # Proceed to evaluate next option

    def _sel_eno(self): # _sel_evaluate_next_option
        self.cM = "SEL"
        if self.sSl["coi"] >= len(self.sSl["so"]): return self.sel_s3peo() # All options evaluated
        co = self.sSl["so"][self.sSl["coi"]] # current_option
        return self.f_aeso(so=co, ec=self.sSl["ec"], cco_=self.cco)

    def sel_sper(self, llr): # SEL-MH: Step - process evaluation result (renamed for clarity)
        self.cM = "SEL"; self.sSl["eo"].append(llr); self.sSl["coi"] += 1; return self._sel_eno()

    def sel_s3peo(self): # SEL-MH Step 3 (present_evaluated_options)
        self.cM = "SEL"; self.pum("Info", "SEL: All options evaluated.")
        do = [] # display_options
        for opt in self.sSl.get("eo", []):
            v = opt.get("oid", str(uid.uuid4())) # value, option_id
            l = opt.get("sum", opt.get("desc", f"Option {v}")) # label, summary, description
            es = self.cjo(opt.get("es", {})) # evaluation_scores
            fl = f"{l} (Scores: {es})" # full_label
            do.append({"v": v, "l": fl, "d": opt}) # Add to display options
        return self.f_ipo("SEL: Review & select a solution:", do)

    def sel_s4fs(self, llr): # SEL-MH Step 4 (finalize_selection)
        self.cM = "SEL"; csi = llr.get("c") # chosen_solution_id, command
        self.sSl["cs"] = next((opt for opt in self.sSl.get("eo", []) if opt.get("oid") == csi), None) # chosen_solution
        if not self.sSl["cs"]: self.pum("Error", f"SEL: Invalid selection ID: {csi}"); return self.k_pmr("SEL", {"s": "SEL_ERR_INV_SEL"})
        ka = self.pco(self.cco.get("kaj", "{}")) # knowledge_artifacts
        ka["selsol"] = self.sSl["cs"] # selected_solution
        self.cco = self.f_ucs(self.cco, "kaj", self.cjo(ka))
        self.cco = self.lco(self.cco, "SEL_RES", "Solution selected.", self.sSl["cs"])
        self.pum("Info", f"SEL: Solution '{csi}' selected.")
        return self.k_pmr("SEL", {"s": "SEL_Complete", "uccoj": self.cjo(self.cco)})

    def kau_s1(self, mi): # KAU-MH Step 1 (initialize)
        self.cM = "KAU"; self.sK = {}; self.lg(self.cM, "S1: Start"); self.pum("Status", "KAU: Starting...")
        if "ccoj" in mi: self.cco = self.pco(mi["ccoj"]); self.kAS = mi["ccoj"] # Load CCO from input if provided
        self.sK["idfl"] = mi.get("dtp", self.cco) # input_data_for_learning, data_to_process
        self.sK["lf"] = mi.get("lf", "general_insights") # learning_focus
        if not self.sK["idfl"]: self.pum("Warning", "KAU: No input data."); return self.k_pmr("KAU", {"s": "KAU_ERR_NO_INPUT", "uccoj": self.cjo(self.cco)})
        return self.f_aled(self.sK["idfl"], self.sK["lf"], self.cco)

    def kau_s2pl(self, llr): # KAU-MH Step 2 (process_learnings)
        self.cM = "KAU"; self.sK["el"] = llr.get("learnings", []) # extracted_learnings
        if not self.sK["el"]: self.pum("Info", "KAU: No learnings extracted."); return self.k_pmr("KAU", {"s": "KAU_NoLearns", "uccoj": self.cjo(self.cco)})
        if not self.cco: self.cco = {"id": f"kau_cco_{uid.uuid4().hex[:4]}", "kaj": "{}", "olj": "[]"}; self.kAS = self.cjo(self.cco); self.lg(self.cM, "Created minimal CCO.")
        ka = self.pco(self.cco.get("kaj", "{}")) # knowledge_artifacts
        if "LHR" not in ka or not isinstance(ka["LHR"], list): ka["LHR"] = []
        ka["LHR"].extend(self.sK["el"])
        self.cco = self.f_ucs(self.cco, "kaj", self.cjo(ka))
        self.cco = self.lco(self.cco, "KAU_RES", "Learnings stored.", {"lc": len(self.sK["el"])})
        self.pum("Info", f"KAU: {len(self.sK['el'])} learnings stored.")
        return self.k_pmr("KAU", {"s": "KAU_Complete", "uccoj": self.cjo(self.cco)})

    # --- FEL-MH (Framework Evolution Loop) Methods ---
    def fel_s1i(self, mi): # FEL-MH Step 1 (initialize_evolution)
        self.cM = "FEL"; self.sFe = {}; self.lg(self.cM, "S1I: Start"); self.pum("Status", "FEL: Starting...")
        self.sFe["cer"] = mi.get("cesm", "Conceptual representation of current Python script.") # current_engine_representation
        self.sFe["eg"] = mi.get("evolution_goal", "General self-improvement.") # evolution_goal
        # Check if autonomous TID generation is requested
        if mi.get("auto_tid", False):
            self.lg(self.cM, "Autonomous TID generation invoked.")
            return self.fel_gen_self_tid(self.sFe["eg"], self.cjo(self.cco))
        else:
            return self.f_iei(pu="FEL: Provide TIDs (JSON) or source.", ch=f"A_MFC_v5().fel_s2lt(r)")

    def fel_s2lt(self, llr): # FEL-MH Step 2 (load_tids)
        self.cM = "FEL"; tsi = llr.get("c") # tid_source_input, command
        self.lg(self.cM, f"S2: Received TID source: {tsi}")
        return self.f_flt({"sd": tsi, "cev": self.vS})

    def fel_s3pt(self, llr): # FEL-MH Step 3 (process_tids)
        self.cM