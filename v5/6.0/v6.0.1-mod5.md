---
modified: 2025-05-26T14:12:51Z
---

--- START OF FILE AIOS_Engine_v6.0.1-mod5.py ---
```python
import json as jsn, uuid as uid, datetime as dt, time as t

# --- Module: AIOSCoreUtils_v6 ---
class AIOSCoreUtils_v6:
    CMD_MAP = {} 

    @staticmethod
    def get_timestamp():
        return dt.datetime.now(dt.timezone.utc).isoformat()

    @staticmethod
    def parse_json_object(json_s, logger_func=None, ctx="Utils"):
        _log = logger_func if logger_func else lambda c, m: print(f"UTIL_LOG({c}):{m}") 
        if not isinstance(json_s, str) or not json_s.strip():
            _log(ctx, "PCO: Null/empty/non-string input. Returning None.")
            return None
        try:
            return jsn.loads(json_s)
        except jsn.JSONDecodeError as e:
            _log(ctx, f"ERR: PCO JSONDecodeError: {e}. Input preview: '{json_s[:70]}...'")
            raise ValueError(f"JSON_PARSE_ERROR_IN_PCO: {e}") from e

    @staticmethod
    def convert_to_json_string(py_obj, logger_func=None, ctx="Utils"):
        _log = logger_func if logger_func else lambda c, m: print(f"UTIL_LOG({c}):{m}")
        if py_obj is None:
            return None
        try:
            return jsn.dumps(py_obj)
        except TypeError as e:
            _log(ctx, f"ERR: CJO TypeError: {e} for object type {type(py_obj)}. Returning None.")
            raise ValueError(f"JSON_FORMAT_ERROR_IN_CJO: {e}") from e
        except Exception as e_gen: 
            _log(ctx, f"ERR: CJO general error: {e_gen} for object type {type(py_obj)}. Returning None.")
            raise ValueError(f"JSON_FORMAT_GENERAL_ERROR_IN_CJO: {e_gen}") from e
    
    @staticmethod
    def generate_id(prefix="id"):
        return f"{prefix}_{uid.uuid4().hex}"

    @staticmethod
    def create_summary_from_text(text, max_len=200):
        if not text or not isinstance(text, str):
            return "No valid text provided for summary."
        return (text[:max_len] + '...') if len(text) > max_len else text

# --- Module: AIOSCognitiveWrappers_v6 ---
class AIOSCognitiveWrappers_v6:
    def __init__(self, main_engine_ref):
        self.eng = main_engine_ref 

    def _prepare_base_request(self, tt, pu, ctd, eid, ch, ccm_override=None):
        original_cM = self.eng.cM
        if ccm_override:
            self.eng.cM = ccm_override
        
        final_ctd = ctd.copy() if ctd else {}
        if "aux_data_refs" in final_ctd and not final_ctd["aux_data_refs"]: 
            del final_ctd["aux_data_refs"]

        req = self.eng._cr(tt=tt, pu=pu, ctd=final_ctd, eid=eid, ch=ch)
        
        if ccm_override: 
            self.eng.cM = original_cM
        return req

    def format_input_prompt_options(self, pu, ol, originating_mh_context, ch_for_callback):
        return self._prepare_base_request(
            tt="UIR_PO", pu=pu, ctd={"opts": ol, "it": "opt_sel"},
            eid="JSON {'s':'UC','c':<val>}", ch=ch_for_callback,
            ccm_override=originating_mh_context
        )

    def format_input_elicit_text(self, pu, originating_mh_context, ch_for_callback, h=None):
        ctd_p = {"it": "ft"}
        if h: ctd_p["h"] = h
        return self._prepare_base_request(
            tt="UIR_ET", pu=pu, ctd=ctd_p,
            eid="JSON {'s':'UC','c':<txt>}", ch=ch_for_callback,
            ccm_override=originating_mh_context
        )

    def format_process_input_document_request(self, raw_input_text, input_ref_id, ch_for_callback, originating_mh_context=None):
        ctd_p = {
            "tsn": "cPID", 
            "raw_text_to_process": raw_input_text, 
            "input_ref_id": input_ref_id, 
            "instructions": "Analyze the provided 'raw_text_to_process'. Extract and return a JSON object with the following keys: 'input_summary' (a concise 1-2 sentence summary of the entire input), 'extracted_keywords' (list of 5-10 significant keywords), 'extracted_key_phrases' (list of 3-5 significant key phrases), 'extracted_proper_names' (list of key proper nouns/named entities), and 'extracted_key_sentences' (list of 1-3 most representative sentences from the input).",
            "ofg": "JSON {'processed_input_details': <structured_object>, 's':'InputProcessed'}"
        }
        eid = "JSON {'processed_input_details': {'input_summary':'...', 'extracted_keywords':[], ...}, 's':'InputProcessed'}"
        return self._prepare_base_request(
            tt="CT_PROCESS_INPUT", pu=None, ctd=ctd_p, eid=eid, ch=ch_for_callback,
            ccm_override=originating_mh_context if originating_mh_context else self.eng.cM
        )

    def format_draft_text_segment(self, i, cx, dlh, rgh, okn="dtxt", ch_for_callback=None, cco_ctx=None, originating_mh_context=None, aux_data_refs=None):
        final_cco_context = cco_ctx if cco_ctx is not None else self.eng.cco
        ctd_p = {"tsn": "cDTS", "i": i, "cx": cx, "dlh": dlh, "rgh": rgh, "ofg": f"JSON{{'{okn}':'...','s':'DraftComplete'}}"}
        if aux_data_refs: ctd_p["aux_data_refs"] = aux_data_refs 

        req = self.eng._cr(tt="CT_DDT", ctd=ctd_p, eid=f"JSON{{'{okn}':'<txt>','s':'DraftComplete'}}",
                           ch=ch_for_callback, ccd_ov=final_cco_context) 
        if originating_mh_context:
            original_cM = self.eng.cM
            self.eng.cM = originating_mh_context
            req = self.eng._cr(tt="CT_DDT", ctd=ctd_p, eid=f"JSON{{'{okn}':'<txt>','s':'DraftComplete'}}",
                           ch=ch_for_callback, ccd_ov=final_cco_context)
            self.eng.cM = original_cM
        return req

    def format_mro_request(self, djs, rgo_obj, cco_s, cmc, ch_for_callback, originating_mh_context=None, aux_data_refs=None):
        ctd = {"djs": djs, "rgo": rgo_obj, "cco_s": cco_s, "cmc": cmc}
        if aux_data_refs: ctd["aux_data_refs"] = aux_data_refs 
        
        parsed_cco_context = self.eng.pco(cco_s) if isinstance(cco_s, str) else cco_s
        
        req = self.eng._cr(tt="CT_MRO_REFINE_STUB", ctd=ctd, 
                           eid="JSON{'refined_djs':'<text_or_json_string_of_refined_doc>','s':'MRO_Done'}", 
                           ch=ch_for_callback, ccd_ov=parsed_cco_context)
        if originating_mh_context: 
            original_cM = self.eng.cM
            self.eng.cM = originating_mh_context
            req = self.eng._cr(tt="CT_MRO_REFINE_STUB", ctd=ctd, 
                           eid="JSON{'refined_djs':'<text_or_json_string_of_refined_doc>','s':'MRO_Done'}", 
                           ch=ch_for_callback, ccd_ov=parsed_cco_context)
            self.eng.cM = original_cM
        return req

    def format_plan_aios_evolution_request(self, evolution_goal, current_aios_summary, ch_for_callback, originating_mh_context=None):
        ctd_p = {
            "tsn": "cPAE", 
            "evolution_goal": evolution_goal,
            "current_aios_summary_and_tids": current_aios_summary, 
            "instructions": "Based on the 'evolution_goal' and 'current_aios_summary_and_tids', propose a conceptual plan for evolving AIOS. Identify key areas/modules for change, suggest new TIDs (Task IDs with descriptions and priorities), and outline potential benefits or challenges. Return a JSON object.",
            "ofg": "JSON {'evolution_plan': {'summary': '...', 'proposed_tids': [], 'discussion': '...'}, 's':'EvolutionPlanDrafted'}"
        }
        eid = "JSON {'evolution_plan': { ... }, 's':'EvolutionPlanDrafted'}"
        return self._prepare_base_request(
            tt="CT_PLAN_EVOLUTION", pu=None, ctd=ctd_p, eid=eid, ch=ch_for_callback,
            ccm_override=originating_mh_context if originating_mh_context else self.eng.cM
        )

# --- Module: AIOS_MH_IFE_v6 --- (Same as v6.0.1-mod4)
class AIOS_MH_IFE_v6: 
    def __init__(self, main_engine_ref, ife_state_dict_ref):
        self.eng = main_engine_ref
        self.sI = ife_state_dict_ref 
        self.mh_name = "IFE"
        self.MAX_SUMMARY_LEN_FOR_STATE = 250 
    def _log(self, message): self.eng.lg(self.mh_name, message)
    def s1(self, mi):
        self._log("S1: Start IFE Process")
        self.eng.pum("Status", f"IFE v{self.eng.vS} (Mod5): Starting Idea Formalization...")
        self.sI.clear() 
        self.sI["current_ife_stage"] = "s1_entry"
        core_idea_from_kernel = mi.get("user_initial_prompt") 
        if core_idea_from_kernel:
            self._log(f"Core idea provided by Kernel/Caller. Passing to S2 for processing.")
            return self.s2({"s": "UC", "c": core_idea_from_kernel, "is_full_content": mi.get("is_full_content", True)}) 
        else:
            self._log("Eliciting core idea/problem statement from user.")
            ch_for_s2 = f"{self.eng.__class__.__name__}().kernel_dispatch_to_mh_callback(r, '{self.mh_name}', 's2')"
            return self.eng.cog_wrappers.format_input_elicit_text(
                pu="IFE (Mod5): What is the core idea, goal, or problem? (Provide text or reference ID that orchestrator can resolve)",
                originating_mh_context=self.mh_name, 
                ch_for_callback=ch_for_s2, 
                h="Provide text directly, or if large, a reference ID known to the orchestrator."
            )
    def s2(self, llr): 
        self._log("S2: Received initial core idea input from user/caller.")
        self.sI["current_ife_stage"] = "s2_process_input_request"
        user_raw_input_text = llr.get("c", "").strip()
        if not user_raw_input_text:
            self.eng.pum("Error", "IFE S2: No core idea text/reference provided. IFE cannot proceed.")
            return {"s": "IFE_Failed_NoCoreIdea", "cco_cur_d": self.eng.cco}
        self.sI["user_raw_input_text_preview"] = self.eng.utils.create_summary_from_text(user_raw_input_text, 100)
        self.sI["input_ref_placeholder"] = f"input_doc_ref_{uid.uuid4().hex[:8]}" 
        self._log(f"Requesting CT_PROCESS_INPUT for: '{self.sI['user_raw_input_text_preview']}'")
        ch_for_s2_callback = f"{self.eng.__class__.__name__}().kernel_dispatch_to_mh_callback(r, '{self.mh_name}', 's2_process_input_callback')"
        return self.eng.cog_wrappers.format_process_input_document_request(
            raw_input_text=user_raw_input_text, 
            input_ref_id=self.sI["input_ref_placeholder"],
            ch_for_callback=ch_for_s2_callback,
            originating_mh_context=self.mh_name
        )
    def s2_process_input_callback(self, llr_ct_result): 
        self._log("S2_CB: Received processed input details from LLM.")
        self.sI["current_ife_stage"] = "s2_process_input_callback"
        processing_status = "failed"
        if llr_ct_result.get("s") == "InputProcessed" and llr_ct_result.get("processed_input_details"):
            processed_input_details = llr_ct_result.get("processed_input_details")
            processing_status = "success"
        else:
            self.eng.pum("Error", "IFE S2_CB: Failed to process input document. Using placeholder for CCO.")
            processed_input_details = {
                "input_summary": "Error: Input document could not be processed by LLM.",
                "extracted_keywords": [], "extracted_key_phrases": [],
                "extracted_proper_names": [], "extracted_key_sentences": []}
        self.sI["processed_input_summary"] = processed_input_details.get("input_summary", "N/A")
        idea_summary_for_cco_name = self.eng.utils.create_summary_from_text(processed_input_details.get("input_summary", "Untitled Idea"), 30)
        cco_id_for_dts = ""
        processed_representation_for_cco = {"processing_status": processing_status, "details": processed_input_details}
        if self.eng.cco is None:
            self._log("No existing CCO. Initializing new CCO with processed input details.")
            new_cco_id = self.eng.utils.generate_id("cco_ife_mod5")
            self.eng.cco = {
                "cco_id": new_cco_id, 
                "metadata_internal_cco": {
                    "name_label": f"AIOS Project (IFE): {idea_summary_for_cco_name}",
                    "current_state_description": "IFE - Input Processed, Ready for Essence Draft",
                    "schema_version_used": self.eng.sV, "engine_version_context": self.eng.vF,
                    "creation_timestamp_utc": self.eng.utils.get_timestamp()}, 
                "op_log_j": [], "core_essence_j": None, 
                "initiating_document_s": { 
                    "input_ref_placeholder": self.sI.get("input_ref_placeholder", "N/A"),
                    "processed_representation": processed_representation_for_cco}}
            self.eng.lco(self.eng.cco, "IFE_NEW_CCO_PROCESSED", f"New CCO '{new_cco_id}' init with processed input (summary): '{idea_summary_for_cco_name}', status: {processing_status}")
            cco_id_for_dts = new_cco_id
            self.eng.pum("Info", f"New project CCO (ID: {new_cco_id}) created with processed input.")
        else: 
            self._log(f"Using existing CCO: {self.eng.cco.get('cco_id', 'N/A')}. Updating with processed input.")
            self.eng.f_ucs(self.eng.cco, "initiating_document_s", {
                "input_ref_placeholder": self.sI.get("input_ref_placeholder", "N/A"),
                "processed_representation": processed_representation_for_cco})
            self.eng.f_ucs(self.eng.cco, "metadata_internal_cco.name_label", f"AIOS Project (IFE Updated): {idea_summary_for_cco_name}")
            self.eng.lco(self.eng.cco, "IFE_UPDATE_CCO_PROCESSED", f"Updated CCO with new processed input (summary): '{idea_summary_for_cco_name}', status: {processing_status}")
            cco_id_for_dts = self.eng.cco.get("cco_id", "EXISTING_CCO_NO_ID_FALLBACK")
        if processing_status == "failed":
            self.eng.pum("Error", "IFE S2_CB: Input processing failed. Cannot proceed to draft project essence.")
            return {"s": "IFE_Error_InputProcessingFailed", "cco_cur_d": self.eng.cco}
        self._log("Requesting LLM to draft 'Project Core Essence Text' using processed input context.")
        ch_for_s3 = f"{self.eng.__class__.__name__}().kernel_dispatch_to_mh_callback(r, '{self.mh_name}', 's3')"
        drafting_context = {"processed_input_details": processed_input_details, "current_cco_id": cco_id_for_dts}
        aux_data_refs_for_drafting = [{"ref_id": self.sI.get("input_ref_placeholder"), "description": "Original full user input document for deep context."}]
        return self.eng.cog_wrappers.format_draft_text_segment(
            i="Based on the provided processed input (summary, keywords, key phrases, sentences), draft a concise 'Project Core Essence Text' (1-3 sentences capturing the project's central theme/goal/problem derived from the input). This will be the project's foundation. Refer to original full text if needed (via aux_data_refs).",
            cx=drafting_context, aux_data_refs=aux_data_refs_for_drafting,
            dlh="1-3 sentences", rgh="project_core_essence_definition", okn="core_essence_txt",
            ch_for_callback=ch_for_s3, cco_ctx=self.eng.cco, originating_mh_context=self.mh_name)
    def s3(self, llr_draft_result): 
        self._log("S3: Received LLM draft for project core essence.")
        self.sI["current_ife_stage"] = "s3_mro_request"
        draft_text = llr_draft_result.get("core_essence_txt")
        llm_status = llr_draft_result.get("s", "UnknownStatus_From_DTS_Essence")
        if not draft_text or llm_status != "DraftComplete":
            self.eng.pum("Warning", f"IFE S3: Core essence draft from LLM incomplete/invalid (Status: {llm_status}). Using placeholder.")
            draft_text = "Placeholder: Project core essence could not be reliably drafted by LLM."
        self.sI["draft_project_essence_payload"] = {"core_essence_txt": draft_text, "llm_dts_status": llm_status}
        self._log(f"Drafted project essence: '{draft_text[:100]}...'. Requesting MRO refinement.")
        rgo = {
            "qcj_s": self.eng.cjo({"Clarity":True, "Conciseness":True, "Impact":True, 
                                   "AlignmentWithProcessedInput":True, "ProjectFocus":True}), 
            "cfh":"Refine the 'core_essence_txt' for maximum impact, clarity, and faithful representation of the initial user idea (referencing its processed representation in CCO, and original full text if needed via orchestrator). Ensure it's a strong foundation for the *project*."}
        aux_data_refs_for_mro = [{"ref_id": self.sI.get("input_ref_placeholder"), "description": "Original full user input document for alignment check during MRO."}]
        ch_for_s4 = f"{self.eng.__class__.__name__}().kernel_dispatch_to_mh_callback(r, '{self.mh_name}', 's4')"
        return self.eng.cog_wrappers.format_mro_request(
            djs=self.eng.cjo(self.sI["draft_project_essence_payload"]),
            rgo_obj=rgo, cco_s=self.eng.cjo(self.eng.cco), cmc=self.mh_name, 
            ch_for_callback=ch_for_s4, originating_mh_context=self.mh_name,
            aux_data_refs=aux_data_refs_for_mro)
    def s4(self, mro_res): 
        self._log("S4: Received MRO refinement result for project core essence.")
        self.sI["current_ife_stage"] = "s4_complete"
        mro_status = mro_res.get("s", "MRO_UnknownStatus")
        final_essence_s = mro_res.get("refined_djs") 
        if not final_essence_s or mro_status != "MRO_Done": 
            self.eng.pum("Warning", f"IFE S4: MRO refinement failed/incomplete (Status: {mro_status}). Using pre-MRO draft.")
            final_essence_s = self.eng.cjo(self.sI.get("draft_project_essence_payload", {"core_essence_txt":"Fallback: MRO error in IFE S4"}))
        final_essence_obj = self.eng.pco(final_essence_s)
        if not final_essence_obj or not isinstance(final_essence_obj.get("core_essence_txt"), str):
             self.eng.pum("Error", "IFE S4: Final core essence content is invalid after MRO. Using placeholder.")
             final_essence_obj = {"core_essence_txt":"Placeholder: Invalid final essence structure post-MRO."}
        if self.eng.cco:
            self.eng.f_ucs(self.eng.cco, "core_essence_j", final_essence_obj) 
            self.eng.f_ucs(self.eng.cco, "metadata_internal_cco.current_state_description", "IFE Complete - Project Essence Defined")
            self.eng.lco(self.eng.cco, "IFE_FINAL_PROJECT_ESSENCE", f"Project core essence finalized. MRO Status: {mro_status}", final_essence_obj)
        else:
            self._log("ERR: CCO is None in IFE S4. Cannot store final essence.")
            return {"s": "IFE_Error_NoCCO_S4", "cco_cur_d": self.eng.cco, "dfl":{"summary":"IFE failed, no CCO to store essence."}}
        self.eng.pum("Status", "IFE: Core Idea Formalization complete. Project essence defined.")
        keys_to_delete_from_sI = ["current_ife_stage", "user_raw_input_text_preview", "input_ref_placeholder", 
                                  "processed_input_summary", "draft_project_essence_payload"]
        for key in keys_to_delete_from_sI:
            if key in self.sI: del self.sI[key]
        return {"s": "IFE_Complete", "cco_cur_d": self.eng.cco, "dfl": {"summary": f"IFE Done for CCO: {self.eng.cco.get('cco_id', 'N/A') if self.eng.cco else 'N/A'}"}}

# --- Module: AIOS_MH_FEL_v6 --- (Same as v6.0.1-mod4)
class AIOS_MH_FEL_v6:
    def __init__(self, main_engine_ref, fel_state_dict_ref):
        self.eng = main_engine_ref
        self.sFe = fel_state_dict_ref 
        self.mh_name = "FEL"
    def _log(self, message): self.eng.lg(self.mh_name, message)
    def s1(self, mi): 
        self._log("S1: Start Framework Evolution Lab Process")
        self.eng.pum("Status", f"FEL v{self.eng.vS} (Mod5): Initiating AIOS Evolution Planning...")
        self.sFe.clear()
        self.sFe["current_fel_stage"] = "s1_entry"
        evolution_goal_from_kernel = mi.get("evolution_goal")
        if evolution_goal_from_kernel:
            self._log(f"Evolution goal provided by Kernel/Caller: '{evolution_goal_from_kernel[:100]}...'")
            return self.s2({"s": "UC", "c": evolution_goal_from_kernel})
        else:
            self._log("Eliciting evolution goal from user.")
            ch_for_s2 = f"{self.eng.__class__.__name__}().kernel_dispatch_to_mh_callback(r, '{self.mh_name}', 's2')"
            return self.eng.cog_wrappers.format_input_elicit_text(
                pu="FEL (Mod5): What is the high-level goal or problem for AIOS evolution?",
                originating_mh_context=self.mh_name,
                ch_for_callback=ch_for_s2,
                h="Describe the desired change, new feature, or problem to solve in AIOS.")
    def s2(self, llr): 
        self._log("S2: Received evolution goal.")
        self.sFe["current_fel_stage"] = "s2_plan_request"
        evolution_goal = llr.get("c", "").strip()
        if not evolution_goal:
            self.eng.pum("Error", "FEL S2: No evolution goal provided. FEL process cannot proceed.")
            return {"s": "FEL_Failed_NoGoal", "cco_cur_d": self.eng.cco}
        self.sFe["evolution_goal"] = evolution_goal
        self._log(f"Evolution goal captured: '{evolution_goal[:150]}...'")
        current_aios_summary = {
            "version": self.eng.vS,
            "key_modules": ["MainEngine", "Kernel", "IFE", "FEL", "CognitiveWrappers", "CoreUtils"],
            "implemented_tids_summary": "Refer to AIOS_v6.0.1-mod5_Implemented_TIDs.json for details. Focus on efficiency, modularity, intelligent input processing, FEL scaffolding, aux_data_refs, CMD_TEST.",
            "pending_evolution_focus": "Further FEL development, other MH implementations, refining CMD_TEST."}
        self._log("Requesting CT_PLAN_AIOS_EVOLUTION cognitive task.")
        ch_for_s3 = f"{self.eng.__class__.__name__}().kernel_dispatch_to_mh_callback(r, '{self.mh_name}', 's3')"
        return self.eng.cog_wrappers.format_plan_aios_evolution_request(
            evolution_goal=evolution_goal,
            current_aios_summary=current_aios_summary,
            ch_for_callback=ch_for_s3,
            originating_mh_context=self.mh_name)
    def s3(self, llr_ct_result): 
        self._log("S3: Received AIOS evolution plan draft from LLM.")
        self.sFe["current_fel_stage"] = "s3_plan_received"
        if llr_ct_result.get("s") != "EvolutionPlanDrafted" or not llr_ct_result.get("evolution_plan"):
            self.eng.pum("Error", "FEL S3: Failed to draft AIOS evolution plan.")
            evolution_plan_details = {"summary": "Error: Evolution plan could not be drafted by LLM."}
            plan_status = "failed"
        else:
            evolution_plan_details = llr_ct_result.get("evolution_plan")
            plan_status = "success"
        self.sFe["draft_evolution_plan"] = evolution_plan_details
        if self.eng.cco:
            if "evolution_lab_outputs" not in self.eng.cco: self.eng.cco["evolution_lab_outputs"] = []
            plan_entry = {
                "timestamp": self.eng.utils.get_timestamp(),
                "goal": self.sFe.get("evolution_goal", "N/A"),
                "plan_status": plan_status,
                "plan_details": evolution_plan_details}
            self.eng.cco["evolution_lab_outputs"].append(plan_entry)
            self.eng.f_ucs(self.eng.cco, "metadata_internal_cco.current_state_description", "FEL - Evolution Plan Drafted")
            self.eng.lco(self.eng.cco, "FEL_EVOLUTION_PLAN_DRAFTED", f"Evolution plan drafted for goal: '{self.sFe.get('evolution_goal','N/A')[:50]}...', status: {plan_status}", plan_entry)
        else: self._log("WARN: FEL S3 - CCO is None. Cannot store evolution plan in CCO.")
        self.eng.pum("Status", f"FEL: AIOS Evolution Plan drafted (Status: {plan_status}). Review CCO 'evolution_lab_outputs'.")
        keys_to_delete_from_sFe = ["current_fel_stage", "evolution_goal", "draft_evolution_plan"]
        for key in keys_to_delete_from_sFe:
            if key in self.sFe: del self.sFe[key]
        return {"s": "FEL_Plan_Complete", "cco_cur_d": self.eng.cco, "dfl": {"summary": "FEL drafted an evolution plan."}}

# --- Module: AIOSKernel_v6 --- (Updated for CMD_TEST)
class AIOSKernel_v6:
    def __init__(self, main_engine_ref):
        self.eng = main_engine_ref
        self.mh_instances = {}
    def _get_mh_instance(self, mh_nid): # Same as mod4
        if mh_nid not in self.mh_instances:
            if mh_nid == "IFE": self.mh_instances[mh_nid] = AIOS_MH_IFE_v6(self.eng, self.eng.sI)
            elif mh_nid == "FEL": self.mh_instances[mh_nid] = AIOS_MH_FEL_v6(self.eng, self.eng.sFe) 
            else: self.eng.lg("Kernel", f"ERR: MH_NID '{mh_nid}' not recognized for instance creation."); return None
        return self.mh_instances[mh_nid]
    
    def k_st_internal(self): # Version number in log updated
        self.eng.cM = "K"; self.eng.lg("K", f"KERNEL_v6:{self.eng.vS} sess start ({'fresh'if not self.eng.kCI else'resume'}).") 
        if self.eng.kCI and self.eng.kCI not in["AUI","TA"]and not self.eng.kCI.startswith("AUI_")and not self.eng.kCI.startswith("CMD_"):
            self.eng.lg("K",f"k_st_int:kCI'{self.eng.kCI}'found.Resume k_rcmh."); return self.k_rcmh()
        else:
            self.eng.lg("K",f"k_st_int:No act kCI('{self.eng.kCI}').Init opts."); self.eng.pum("Status",f"AIOS Eng {self.eng.vS}(Mod5)init."); return self.k_pio()
    def k_pio(self): # Version number in pu updated
        self.eng.cM = "K"; self.eng.lg("K", "PIO: Init cmd opts.")
        init_opts_k = ["NEW","EVOLVE","LOAD","STATUS","HELP","TERMINATE", "TEST"] # Added TEST
        opts = [{"v":k,"l":f"{i+1}. {k} ({self.eng.CMD_MAP[k]if self.eng.CMD_MAP[k]not in['TA']and not self.eng.CMD_MAP[k].startswith('CMD_')else'Sys Cmd'})"} for i,k in enumerate(init_opts_k)if k in self.eng.CMD_MAP]
        ch_for_pirc = f"{self.eng.__class__.__name__}().kernel_pirc(r)" 
        return self.eng._cr(tt="UIR_PO", pu=f"AIOS Eng v{self.eng.vS}(Mod5)ready.Cmd:", ctd={"opts":opts,"it":"opt_sel"}, eid="JSON {'s':'UC','c':<val>}", ch=ch_for_pirc)
    
    def kernel_pirc_internal(self, llr): # Same as mod4
        self.eng.cM = "K"
        try:
            if not llr or not isinstance(llr,dict)or llr.get("s")!="UC": self.eng.lg("K",f"ERR:Inv init choice:{str(llr)[:50]}");self.eng.pum("Warning","Inv choice.Retry.");return self.k_pio()
            cmd_chc=llr.get("c","").strip().upper(); self.eng.lg("K",f"kernel_pirc_int:Proc cmd:'{cmd_chc}'")
            dir_int=self.eng.f_iud(cmd_chc); self.eng.kCI=dir_int.get("nid","AUI_UNK"); self.eng.kMI=dir_int.get("nijs","{}")
            if self.eng.kCI=="AUI_UNK": self.eng.pum("Warning",dir_int.get("upm",f"Unk choice:'{cmd_chc}'.")); return self.k_pio()
            if self.eng.kCI=="TA": self.eng.pum("Status","TA by user."); return{"s":"TERM_REQ","fes":self.eng.exs(),"message":"TA req."} 
            self.eng.lg("K",f"K:Next kCI:{self.eng.kCI} from init."); return self.k_rcmh()
        except Exception as e: self.eng.lg("K",f"ERR_CRIT:kernel_pirc_int ex:{e}");self.eng.pum("Error",f"Crit err proc choice:{e}.");return self.k_pio()
    
    def k_rcmh(self): # Added CMD_TEST handler
        self.eng.cM="K_DISP"; cur_kCI=self.eng.kCI
        ch_k_pgud = f"{self.eng.__class__.__name__}().k_pgud(r)"
        if cur_kCI=="TA": self.eng.lg("K_DISP","TA instr K.Terminating."); self.eng.pum("Status","AIOS Eng sess term instruction."); return{"s":"TERM","fes":self.eng.exs(),"message":"Sess term."}
        if cur_kCI=="AUI"or not cur_kCI or cur_kCI.startswith("AUI_"):
            self.eng.cM="K_AUI";self.eng.lg("K_AUI",f"K Paused(kCI:{cur_kCI}).Await GUD.");p_msg="AIOS paused.Enter cmd (NEW, STATUS, HELP, TERMINATE, OK, RESUME, TEST):"; # Added TEST to prompt
            if cur_kCI=="AUI_MH_ERR":
                fail_mh_info={};fmh_s="Unk";fstat_s="Unk"
                try:fail_mh_info=self.eng.pco(self.eng.kMI)if self.eng.kMI else{}
                except:pass
                if fail_mh_info:fmh_s=fail_mh_info.get('failed_mh','Unk');fstat_s=fail_mh_info.get('status','Unk')
                p_msg=f"MH Err(MH:{fmh_s},Stat:{fstat_s}). {p_msg}"
            return self.eng._cr("UIR_GD",p_msg,eid="User txt cmd.",ch=ch_k_pgud)
        if cur_kCI=="CMD_STATUS": return self.eng._k_cmd_action(cur_kCI,"INFO_STAT_RPT","Eng stat rept gen.",self.eng._get_stat_info,"Stat rept gen.","CMD_STAT_EXE", ch_next=ch_k_pgud)
        if cur_kCI=="CMD_HELP": return self.eng._k_cmd_action(cur_kCI,"INFO_HELP_TXT","Help info prov.",self.eng._get_help_info,"Help info gen.","CMD_HELP_EXE", ch_next=ch_k_pgud)
        if cur_kCI=="CMD_TEST": # NEW: CMD_TEST handler
            return self.eng._k_cmd_action(cur_kCI, 
                                       "INFO_DIAGNOSTIC_REPORT", 
                                       "Engine diagnostics report.", 
                                       self.eng._run_diagnostics, # Call to new diagnostic method
                                       "Diagnostic routine executed.", 
                                       "CMD_TEST_EXE", 
                                       ch_next=ch_k_pgud)
        if cur_kCI == "CMD_ACK_PROCEED": 
            self.eng.lg("Kernel", "User acknowledged (CMD_ACK_PROCEED). Transitioning to AUI.")
            self.eng.kCI = "AUI"; self.eng.kMI = "{}"
            return self.k_rcmh() 
        
        mh_tgt_nid=self.eng.CMD_MAP.get(cur_kCI,cur_kCI); disp_mhs=["IFE", "FEL"] 
        if mh_tgt_nid in disp_mhs:
            self.eng.cM=mh_tgt_nid; self.eng.lg("Kernel",f"Dispatch to MH:{mh_tgt_nid}(Orig kCI:{cur_kCI})")
            mh_inst=self._get_mh_instance(mh_tgt_nid)
            if mh_inst: 
                mh_in_p = self.eng.pco(self.eng.kMI) or {} 
                return mh_inst.s1(mh_in_p) 
            self.eng.kCI="AUI_MH_ERROR";self.eng.kMI=self.eng.cjo({"fmh":mh_tgt_nid,"err":"Inst fail"});return self.k_rcmh()
        
        self.eng.lg("Kernel",f"ERR:kCI '{cur_kCI}'(map '{mh_tgt_nid}') !recog for MH dispatch or specific cmd. Default AUI.");
        self.eng.kCI="AUI_UNK_KCI"; 
        self.eng.kMI = self.eng.cjo({"unrecognized_kci": cur_kCI, "mapped_as": mh_tgt_nid})
        return self.k_rcmh()

    # k_pmr_internal, k_pgud_internal, load/save stubs are same as mod4
    def k_pmr_internal(self, mjid, mhr): 
        self.eng.cM = "K_PMR"; s_stat=mhr.get("s","UnkStat"); self.eng.lg("K_PMR",f"Proc res MH '{mjid}'.Stat:'{s_stat}'")
        if not mhr or not isinstance(mhr, dict): 
            self.eng.lg("K_PMR", f"ERR: Invalid/non-dict MHR from {mjid}."); self.eng.kCI="AUI_MH_CORRUPT"; return self.k_rcmh()
        if "cco_cur_d" in mhr and isinstance(mhr["cco_cur_d"],dict): self.eng.cco = mhr["cco_cur_d"]; self.eng.kAS=self.eng.cjo(self.eng.cco)
        if s_stat=="A_LLM": return mhr 
        if self.eng.cco: self.eng.lco(self.eng.cco,"MH_COMP_STAT_RPT",f"MH '{mjid}' fin.Stat:{s_stat}.",mhr.get("dfl"))
        if any(ei in s_stat.upper()for ei in["ERROR","FAILED","ERR_","_ERR"]): self.eng.kCI="AUI_MH_ERR";self.eng.kMI=self.eng.cjo({"fmh":mjid,"stat":s_stat,"dfl":mhr.get("dfl")});return self.k_rcmh()
        next_mh_nid="AUI"; default_seq_map={"IFE":"PDF"} 
        if mjid in default_seq_map and "Complete" in s_stat: 
            next_mh_nid = default_seq_map[mjid]
            self.eng.lg("K_PMR", f"Default sequence: {mjid} complete, next is {next_mh_nid}.")
        elif "Complete" in s_stat: 
             self.eng.pum("Suggestion",f"MH {mjid} completed. Consider SAVE or next command.")
        self.eng.kCI=next_mh_nid; self.eng.kMI="{}"; return self.k_rcmh()
    def k_pgud_internal(self, llr):
        self.eng.cM = "K_AUI_PROC"; udt=llr.get("c","");
        if not udt: self.eng.kCI="AUI";return self.k_rcmh()
        self.eng.lg("K_AUI_PROC", f"Processing GUD: '{udt[:70]}'") 
        ir=self.eng.f_iud(udt); self.eng.kCI=ir.get("nid","AUI_UNK_CMD"); self.eng.kMI=ir.get("nijs","{}")
        if self.eng.kCI=="AUI_UNK_CMD":
            ch_k_pgud_again = f"{self.eng.__class__.__name__}().k_pgud(r)"
            return self.eng._cr("UIR_GD",ir.get("upm","Cmd unk."),ch=ch_k_pgud_again)
        return self.k_rcmh()
    def kernel_load_cco_handler_internal(self, llr): self.eng.lg("K","kernel_load_cco_handler_internal STUB"); self.eng.kCI="AUI"; return self.k_rcmh()
    def kernel_save_cco_handler_internal(self, llr): self.eng.lg("K","kernel_save_cco_handler_internal STUB"); self.eng.kCI="AUI"; return self.k_rcmh()


# --- Module: AIOSMainEngine_v6 --- (Updated for v6.0.1-mod5)
class AIOSMainEngine_v6:
    CMD_MAP = {} 
    MH_NAMES_AS_COMMANDS = ["IFE", "PDF", "PLN", "TDE", "CAG", "SEL", "KAU", "FEL", "MRO"]
    MAX_SUMMARY_LENGTH_FOR_STATE_STORAGE = 250

    def __init__(self, i_sjs=None):
        self.lh = []
        self.vF = "AIOS_Engine_v6.0.1-mod5"; self.vS = "6.0.1-mod5" 
        self.cM = "Sys"; self.sV = "3.0.1-mod5" 
        self.kAS, self.kCI, self.kMI, self.cco = None, None, None, None
        self.sI,self.sP,self.sPl,self.sCg,self.sT,self.sSl,self.sK,self.sFe,self.sMr = {},{},{},{},{},{},{},{},{}
        self._is_reflecting = False
        if not hasattr(self, 'lh') or not isinstance(self.lh, list): self.lh = []
        
        self.CMD_MAP = { "NEW": "IFE", "EVOLVE": "FEL", "TERMINATE": "TA", 
                         "STATUS": "CMD_STATUS", "HELP": "CMD_HELP", 
                         "LOAD": "CMD_LOAD", "SAVE": "CMD_SAVE", "TEST": "CMD_TEST", 
                         "OK": "CMD_ACK_PROCEED", "PROCEED": "CMD_ACK_PROCEED", 
                         "CONTINUE": "CMD_ACK_PROCEED", "NEXT": "CMD_ACK_PROCEED", 
                         "YES": "CMD_ACK_PROCEED", "RESUME": "CMD_ACK_PROCEED"} 
        for mh_cmd in self.MH_NAMES_AS_COMMANDS: 
            if mh_cmd not in self.CMD_MAP: self.CMD_MAP[mh_cmd] = mh_cmd
        AIOSCoreUtils_v6.CMD_MAP = self.CMD_MAP

        self.utils = AIOSCoreUtils_v6
        self.cog_wrappers = AIOSCognitiveWrappers_v6(self)
        self.kernel = AIOSKernel_v6(self)

        self.lg("Sys", f"INIT: MainEngine {self.vS} Started.")
        if i_sjs:
            try: self.is_(i_sjs)
            except Exception as e: self.lg("Sys", f"ERR: MainEngine State import fail: {e}. Defaults."); self._ids()
        else: self._ids(); self.lg("Sys", f"INIT: MainEngine {self.vS} (default state).")
        self.lg("Sys", "INIT: MainEngine Done.")

    def _ids(self):
        lh_bak = self.lh if hasattr(self, 'lh') and isinstance(self.lh, list) else []
        attrs_to_set = {"vF":self.vF, "vS":self.vS, "cM":"Sys", "sV":self.sV, 
                        "kAS":None,"kCI":None,"kMI":None,"cco":None,"sI":{},"sP":{},"sPl":{},"sCg":{},"sT":{},
                        "sSl":{},"sK":{},"sFe":{},"sMr":{},"_is_reflecting":False}
        for k,v in attrs_to_set.items(): setattr(self, k, v)
        self.lh = lh_bak
        if not hasattr(self, 'kernel') or (hasattr(self, 'kernel') and self.kernel.eng is not self): 
            self.kernel = AIOSKernel_v6(self)
        if not hasattr(self, 'cog_wrappers') or (hasattr(self, 'cog_wrappers') and self.cog_wrappers.eng is not self): 
            self.cog_wrappers = AIOSCognitiveWrappers_v6(self)

    def exs(self): # Same as mod4
        MAX_LOG=50; lh_exp=self.lh[-MAX_LOG:] if len(self.lh)>MAX_LOG else self.lh
        lh_s=None
        if len(self.lh)>MAX_LOG: lh_s={"tot":len(self.lh),"shw":len(lh_exp),"old_ts":lh_exp[0][:26]if lh_exp else None}
        cco_s = self.cjo(self.cco)
        sd={"sV":self.sV,"vF":self.vF,"vS":self.vS,"cM":self.cM,"kAS_t":"json_s","kAS":cco_s,"kCI":self.kCI,"kMI":self.kMI,"_is_refl":self._is_reflecting,"lh_s":lh_s,"lh":lh_exp}
        for s_k in ['sI','sP','sPl','sCg','sT','sSl','sK','sFe','sMr']: 
            sd[s_k] = getattr(self,s_k)
        return self.cjo(sd)

    def is_(self, sjs): # Updated sV compatibility
        try: sd = self.pco(sjs) 
        except ValueError: self._ids(); return 
        if not sd: self.lg("Sys", "WARN: is_ null/empty state. Defaults."); self._ids(); return
        
        loaded_sV = sd.get("sV")
        compatible_sVs = ["3.0.1-mod1", "3.0.1-mod2", "3.0.1-mod3", "3.0.1-mod4", "3.0.1-mod5"] 
        if loaded_sV != self.sV and loaded_sV not in compatible_sVs:
             self.lg("Sys",f"WARN:sV mismatch.Eng:{self.sV},Imp:{loaded_sV}. Potential compatibility issues.")
        if sd.get("vS") and sd.get("vS")!=self.vS : self.lg("Sys",f"State vS {sd.get('vS')} noted. Engine remains {self.vS}.")

        self.cM=sd.get("cM","Sys"); self.kAS=sd.get("kAS"); self.kCI=sd.get("kCI"); self.kMI=sd.get("kMI")
        try: self.cco=self.pco(self.kAS) if self.kAS else None 
        except ValueError: self.lg("Sys",f"ERR:CCO deserial fail in is_().CCO None.");self.cco=None
        
        for s_k in ['sI','sP','sPl','sCg','sT','sSl','sK','sFe','sMr']: 
            setattr(self,s_k,sd.get(s_k,{}))

        self.lh=sd.get("lh",[]); self._is_reflecting=sd.get("_is_refl",False)
        if sd.get("lh_s"): self.lg("Sys",f"Log import(sum:{sd['lh_s']})")
        self.lg("Sys",f"IS:Done.Eng v{self.vS}.MHFromState {self.cM}.CCO Loaded:{'Y'if self.cco else'N'}.")

    # lg, _cr, pum, pco, cjo, lco, f_ucs, f_iud are same as mod4
    def lg(self, c, m): 
        fl=f"{self.utils.get_timestamp()} - LG ({c} v{self.vS}): {m}"; print(fl)
        if not hasattr(self, 'lh') or not isinstance(self.lh, list): self.lh = []
        self.lh.append(fl)
    def _cr(self, tt, pu=None, ctd=None, eid=None, ch=None, ccd_ov=None):
        r={"rts":self.utils.get_timestamp(),"evc":self.vF,"ccm":self.cM,"tt":tt}
        if pu: r["pu"]=pu
        if ctd: 
            r["ctd"]=ctd
            if "aux_data_refs" in ctd and ctd["aux_data_refs"]:
                 r["aux_data_refs_passthrough"] = ctd["aux_data_refs"]
        if eid: r["eid"]=eid
        if ch: r["ch"]=ch
        cco_p=ccd_ov if ccd_ov is not None else self.cco
        if cco_p:r["ccd"]=cco_p if isinstance(cco_p,dict)else{"err_cr_cco_type":f"{type(cco_p).__name__}"}
        return {"s":"A_LLM","rd":r,"ces":self.exs()}
    def pum(self,mt,mc): self.lg(self.cM,f"PUM:{mt}:{str(mc)[:70]}..."); return self._cr("PUM",ctd={"mt":mt,"c":mc,"om":self.cM},ch="Orch.display_msg")
    def pco(self, jsi): return self.utils.parse_json_object(jsi, self.lg, self.cM)
    def cjo(self, coi): return self.utils.convert_to_json_string(coi, self.lg, self.cM)
    def lco(self, cco_d, let, msg, ado=None): 
        if not isinstance(cco_d,dict): self.lg(self.cM,f"LCO:CCO!dict({type(cco_d).__name__}).Rec/init."); cco_d=self.cco if isinstance(self.cco,dict)else{"id":self.utils.generate_id("cco_lco_emg"),"op_log_j":[]}; self.cco=cco_d
        lk="op_log_j";cl=cco_d.get(lk,[]);
        if not isinstance(cl,list):cl=[]
        nle={"ts":self.utils.get_timestamp(),"let":let,"lm":msg,"mh_c":self.cM};
        if ado is not None:
            try:jsn.dumps(ado);nle["ado"]=ado
            except TypeError:nle["ado_err"]=f"Unserializable ADD_DATA_OBJECT_TYPE:{type(ado).__name__}"
        cl.append(nle);cco_d[lk]=cl;self.cco=cco_d;
        try: self.kAS=self.cjo(self.cco)
        except ValueError as e: self.lg(self.cM,f"ERR:LCO CCO unstringifyable:{e}.kAS stale."); self.kAS=None
        return cco_d
    def f_ucs(self, cco_d, sp, ncj): 
        if not isinstance(cco_d,dict):self.lg(self.cM,f"ERR:fUCS CCO!dict({type(cco_d).__name__}).P:{sp}");return cco_d
        ks=sp.split('.');cl=cco_d
        try:
            for i_idx,k_val in enumerate(ks):
                if i_idx==len(ks)-1:cl[k_val]=ncj
                else:
                    if k_val not in cl or not isinstance(cl[k_val],dict):cl[k_val]={}
                    cl=cl[k_val]
            self.cco=cco_d; 
            try:self.kAS=self.cjo(self.cco) 
            except ValueError as e:self.lg(self.cM,f"ERR:fUCS CCO unstringifyable:{e}.kAS stale.")
            return cco_d
        except Exception as ex:self.lg(self.cM,f"ERR:fUCS gen fail'{sp}':{ex}.CCO may be inconsist.");return cco_d
    def f_iud(self, u_in_txt): 
        std_in=u_in_txt.strip().upper();nid="AUI_UNK";params_s="{}";upm=f"Cmd '{u_in_txt}' not understood."
        if std_in in self.CMD_MAP:
            nid=self.CMD_MAP[std_in];upm=None
            self.lg(self.cM, f"f_iud: Parsed '{std_in}' to NID '{nid}'.")
        else:
            self.lg(self.cM,f"f_iud: Input '{std_in}' not in CMD_MAP. Unknown to direct parser.")
        res={"s":"OK"if nid!="AUI_UNK"else"Clarify","nid":nid,"nijs":params_s}
        if upm:res["upm"]=upm
        return res

    # Kernel Interface Methods are same as mod4
    def k_st(self, sjs_passthrough=None): 
      if sjs_passthrough: self.lg("MainEngine","k_st called with state string. Re-initializing with provided state."); self.__init__(i_sjs=sjs_passthrough)
      elif not self.vS: self.lg("MainEngine","k_st called on potentially uninitialized instance. Ensuring full init."); self.__init__() 
      return self.kernel.k_st_internal()
    def kernel_pirc(self, llr): 
        return self.kernel.kernel_pirc_internal(llr)
    def k_pgud(self, llr): 
        self.lg("MainEngine", f"k_pgud received: {str(llr)[:100]}. Current kCI: {self.kCI}, cM: {self.cM}")
        return self.kernel.k_pgud_internal(llr)
    def kernel_load_cco_handler(self, llr): 
        return self.kernel.kernel_load_cco_handler_internal(llr) 
    def kernel_save_cco_handler(self, llr): 
        return self.kernel.kernel_save_cco_handler_internal(llr) 
    def kernel_dispatch_to_mh_callback(self, llr_fc, mh_nid_orig, mh_meth_orig): 
        original_cM = self.cM; self.cM = "K_CB_DISP" 
        self.lg("MainEngine", f"Dispatching LLM/Cognitive response back to MH: {mh_nid_orig}, Method: {mh_meth_orig}")
        mh_inst = self.kernel._get_mh_instance(mh_nid_orig)
        response_pkg = None
        if mh_inst and hasattr(mh_inst, mh_meth_orig):
            mh_result_package = getattr(mh_inst, mh_meth_orig)(llr_fc) 
            response_pkg = self.kernel.k_pmr_internal(mh_nid_orig, mh_result_package)
        else:
            self.lg("MainEngine", f"ERR: MH instance or callback method not found for: {mh_nid_orig}.{mh_meth_orig}")
            self.kCI = "AUI_MH_ERROR" 
            self.kMI = self.cjo({"fmh":mh_nid_orig,"err":f"Callback method '{mh_meth_orig}' not found on MH instance."})
            response_pkg = self.kernel.k_rcmh() 
        self.cM = original_cM 
        return response_pkg
            
    def _k_cmd_action(self, cmd_nid, tt_s, pu_b, ctd_fn_val, log_msg_b, cco_log_evt=None, ch_next=None):
        original_cM = self.cM; self.cM=f"K_{cmd_nid}" 
        self.lg(self.cM,f"Executing Kernel Command '{cmd_nid}': {log_msg_b}")
        ctd_value = ctd_fn_val() if callable(ctd_fn_val) else ctd_fn_val
        if self.cco and cco_log_evt:
            self.lco(self.cco,cco_log_evt,f"Kernel command '{cmd_nid}' processed.",{"summary_of_ctd_payload":str(ctd_value)[:70]})
        
        ch_to_use = ch_next if ch_next else f"{self.__class__.__name__}().k_pgud(r)"
        response_package = self._cr(tt_s,f"{pu_b} Ready for next command.",ctd_value,ch=ch_to_use)
        
        self.kCI = "AUI" 
        self.kMI = "{}"
        self.lg(self.cM, f"Kernel command '{cmd_nid}' finished. kCI set to AUI by _k_cmd_action.")

        self.cM = original_cM 
        return response_package

    def _get_stat_info(self): # Same as mod4
        fel_state_summary = "N/A"
        if self.sFe:
            fel_stage = self.sFe.get("current_fel_stage", "N/A")
            fel_goal_summary = self.eng.utils.create_summary_from_text(self.sFe.get("evolution_goal",""), 50)
            fel_state_summary = f"Stage: {fel_stage}, Goal Summary: {fel_goal_summary}"
            if "draft_evolution_plan" in self.sFe:
                fel_state_summary += ", Plan Drafted"
        
        return {"engine_version":self.vS, "state_schema_version":self.sV,
                "current_module_context":self.cM, 
                "kernel_current_instruction_id":self.kCI, 
                "active_cco_id":self.cco.get("cco_id","None") if self.cco else "None",
                "cco_metadata_state_description":self.cco.get("metadata_internal_cco",{}).get("current_state_description","N/A") if self.cco else "N/A",
                "cco_initiating_input_summary": self.cco.get("initiating_document_s",{}).get("processed_representation",{}).get("details",{}).get("input_summary","N/A") if self.cco else "N/A",
                "ife_state_current_stage": self.sI.get("current_ife_stage", "N/A") if self.sI else "N/A",
                "ife_state_input_summary": self.sI.get("processed_input_summary", "N/A") if self.sI else "N/A",
                "fel_state_summary": fel_state_summary, 
                "log_entries_in_memory":len(self.lh), "self_reflection_flag_active":self._is_reflecting,
                "timestamp_utc":self.utils.get_timestamp()}

    def _get_help_info(self): # Added TEST to user_facing_cmds
        user_facing_cmds = [k for k in self.CMD_MAP.keys() if k in ["NEW","EVOLVE","TERMINATE","STATUS","HELP","LOAD","SAVE","TEST","OK","RESUME"] or self.CMD_MAP[k] in self.MH_NAMES_AS_COMMANDS]
        main_help_text=(f"AIOS Engine v{self.vS}. Global Commands: {', '.join(user_facing_cmds)}.\n"
                        f"Use these commands when engine is paused (AUI state) or from the initial prompt.\n"
                        f"Current CCO: {'Loaded (ID: '+str(self.cco.get('cco_id','N/A'))+')' if self.cco else 'Not currently loaded'}.\n" 
                        f"Current Engine Context for this help report: {self.cM}.") 
        return {"main_help_text":main_help_text,"available_user_commands":user_facing_cmds,"engine_version":self.vS}

    def _run_diagnostics(self): # NEW: Diagnostic routine for CMD_TEST
        self.lg(self.cM, "Running diagnostics...") # cM will be K_CMD_TEST
        results = {"timestamp_utc": self.utils.get_timestamp(), "engine_version_tested": self.vS, "diag_schema_version": "1.0"}
        
        mh_checks = {}
        # MHs to check for basic integrity (FEL added)
        test_mhs = ["IFE", "FEL"] 
        results["mh_to_test_list"] = test_mhs

        for mh_nid in test_mhs:
            mh_check_result = {"instantiated": False, "s1_found": False, "errors": []}
            try:
                mh_inst = self.kernel._get_mh_instance(mh_nid)
                if mh_inst:
                    mh_check_result["instantiated"] = True
                    if hasattr(mh_inst, "s1") and callable(getattr(mh_inst, "s1")):
                        mh_check_result["s1_found"] = True
                    else:
                        mh_check_result["errors"].append("s1 method not found or not callable.")
                else:
                     mh_check_result["errors"].append(f"Failed to get instance for {mh_nid}")
            except Exception as e:
                mh_check_result["errors"].append(f"Instantiation exception: {str(e)}")
            mh_checks[mh_nid] = mh_check_result
        results["mh_integrity_checks"] = mh_checks

        cco_checks = {"cco_loaded": False, "schema_elements_present": {}, "errors": []}
        if self.cco and isinstance(self.cco, dict):
            cco_checks["cco_loaded"] = True
            key_elements = ["cco_id", "metadata_internal_cco", "op_log_j", "core_essence_j", "initiating_document_s"]
            # "evolution_lab_outputs" is optional, so not checking its presence as mandatory
            
            if not self.cco.get("cco_id"):
                cco_checks["errors"].append("cco_id is missing or empty.")
            
            meta_cco = self.cco.get("metadata_internal_cco")
            if not isinstance(meta_cco, dict):
                cco_checks["errors"].append("metadata_internal_cco is missing or not a dict.")
            else:
                for k_meta in ["name_label", "current_state_description", "schema_version_used", "engine_version_context", "creation_timestamp_utc"]:
                    cco_checks["schema_elements_present"][f"metadata.{k_meta}"] = k_meta in meta_cco
                    if k_meta not in meta_cco: cco_checks["errors"].append(f"metadata_internal_cco missing key: {k_meta}")
            
            for elem in ["op_log_j", "core_essence_j", "initiating_document_s"]:
                cco_checks["schema_elements_present"][elem] = elem in self.cco
                # More detailed checks could be added (e.g., op_log_j is list)
                if elem == "op_log_j" and not isinstance(self.cco.get(elem), list):
                    cco_checks["errors"].append(f"{elem} is not a list.")
        elif self.cco: # CCO exists but is not a dict
            cco_checks["errors"].append(f"CCO is present but not a dictionary (type: {type(self.cco).__name__}).")
        results["cco_schema_compliance_basic"] = cco_checks
        
        num_mh_errors = sum(1 for mh_res in mh_checks.values() if mh_res["errors"] or not mh_res["instantiated"] or not mh_res["s1_found"])
        num_cco_errors = len(cco_checks["errors"])

        if num_mh_errors == 0 and num_cco_errors == 0 and cco_checks["cco_loaded"]:
            results["overall_status"] = "PASS"
            results["summary"] = f"Diagnostics complete. All basic checks passed for {len(test_mhs)} MHs and loaded CCO."
        elif num_mh_errors == 0 and not cco_checks["cco_loaded"]:
            results["overall_status"] = "PASS_NO_CCO"
            results["summary"] = f"Diagnostics complete. All basic MH checks passed. No CCO loaded to check."
        else:
            results["overall_status"] = "FAIL"
            results["summary"] = f"Diagnostics complete. MH Errors: {num_mh_errors}. CCO Errors: {num_cco_errors}."

        self.lg(self.cM, results["summary"])
        # Store a brief summary of the last test in sK (Kernel state) for potential inclusion in STATUS
        self.sK["last_test_summary"] = {"timestamp": results["timestamp_utc"], "status": results["overall_status"]}
        return results

# --- Stubs for other MHs ---
class AIOS_MH_PDF_v6: 
    def __init__(self,e,s):self.eng=e;self.sP=s;self.mh_name="PDF" 
    def s1(self,mi): self.eng.lg(self.mh_name, "S1 STUB"); return{"s":"PDF_Stub_Complete","cco_cur_d":self.eng.cco}


if __name__ == "__main__":
    print("--- AIOS Engine v6.0.1-mod5 Modular Script Execution Start (Consolidated Turn 1) ---")
    engine_instance_main = AIOSMainEngine_v6() 
    output_package_for_orchestrator = engine_instance_main.k_st()
    print(jsn.dumps(output_package_for_orchestrator, indent=2))
    print("--- AIOS Engine v6.0.1-mod5 Modular Script Execution End (Consolidated Turn 1) ---")
```
--- END OF FILE AIOS_Engine_v6.0.1-mod5.py ---

--- START OF FILE AIOS_v6.0.1-mod5_ChangeLog.md ---
# AIOS Engine v6.0.1-mod5 Change Log

## Version 6.0.1-mod5 (Conceptual Release: [Current Date])

This version implements the `CMD_TEST` functionality as planned by the Framework Evolution Lab (FEL) in `v6.0.1-mod4`. It introduces a diagnostic routine to perform basic health checks on the engine's core components.

### Key Changes:

*   **Implemented `CMD_TEST` Functionality (`TID_KERNEL_CMD_TEST_V1`, `TID_DIAGNOSTIC_ROUTINE_V1`):**
    *   **`AIOSKernel_v6.k_rcmh`:** Added a handler for `kCI == "CMD_TEST"`. This handler calls `self.eng._k_cmd_action` with a new method `self.eng._run_diagnostics` as the function to generate the `ctd` for an `INFO_DIAGNOSTIC_REPORT`.
    *   **`AIOSMainEngine_v6._run_diagnostics()` (New Method):**
        *   This method performs several diagnostic checks:
            *   **MH Integrity:** For registered MHs (currently IFE, FEL), it attempts to get an instance via `self.kernel._get_mh_instance()` and checks if the instance has a callable `s1` method. Records success/failure and any errors.
            *   **CCO Schema Compliance (Basic):** If a CCO is loaded (`self.cco` is not `None` and is a `dict`):
                *   Checks for the presence of `cco_id`.
                *   Checks if `metadata_internal_cco` is a dict and contains essential keys (`name_label`, `current_state_description`, `schema_version_used`, etc.).
                *   Checks for the presence of top-level keys like `op_log_j`, `core_essence_j`, `initiating_document_s`.
                *   Checks if `op_log_j` is a list.
            *   Records errors found during CCO checks.
        *   Returns a dictionary containing the detailed results of these checks, including an `overall_status` ("PASS", "PASS_NO_CCO", "FAIL") and a summary message.
        *   Stores a brief summary of the test outcome (timestamp, status) in `self.sK["last_test_summary"]` (Kernel state).
*   **User Interface Updates for TEST:**
    *   `CMD_MAP` in `AIOSMainEngine_v6` already included `"TEST": "CMD_TEST"`.
    *   The AUI prompt in `AIOSKernel_v6.k_rcmh` now includes "TEST" as an available command.
    *   The initial command options list in `AIOSKernel_v6.k_pio` now includes "TEST".
*   **Minor Updates:**
    *   Version strings updated to `v6.0.1-mod5`.
    *   State Schema version updated to `3.0.1-mod5`.
    *   Log messages updated to reflect "Mod5".
    *   `_get_help_info` in `AIOSMainEngine_v6` updated to include TEST in its example command list if it wasn't already clear.

### Impact:

*   **Basic Engine Health Check:** The `TEST` command now provides a functional diagnostic capability, offering insights into MH integrity and basic CCO structure. This is a foundational step for more comprehensive self-testing and validation.
*   **FEL Loop Demonstration:** This completes a conceptual loop where FEL proposed an evolution (implement `CMD_TEST`), and that evolution has now been implemented.

This version marks an important step in AIOS's ability to self-monitor and provides a concrete example of the FEL's utility.

--- END OF FILE AIOS_v6.0.1-mod5_ChangeLog.md ---

--- START OF FILE AIOS_User_Manual_v6.0.1-mod5.md ---
# AIOS Engine v6.0.1-mod5 - User Manual (Draft)

## 1. Introduction to AIOS v6.0.1-mod5

AIOS Engine v6.0.1-mod5 implements the `CMD_TEST` functionality, allowing users to run basic diagnostic checks on the engine's core components. This feature was conceptually planned by the Framework Evolution Lab (FEL) in a previous iteration.

**Purpose:** Orchestrate complex processes, manage its own evolution (via FEL), and provide self-diagnostic capabilities.

**LLM Orchestrator Responsibilities:** (Same as `v6.0.1-mod4`)
*   Script persistence after Turn 1.
*   `ces` management.
*   Handling large inputs and fulfilling cognitive tasks, including providing auxiliary data if requested by AIOS via `rd.aux_data_refs_passthrough`.

## 2. Key Architectural Changes in v6.0.1-mod5

*   **`CMD_TEST` Implementation:**
    *   The `TEST` command now triggers a diagnostic routine (`AIOSMainEngine_v6._run_diagnostics`).
    *   This routine checks:
        *   Integrity of registered Meta-Handlers (IFE, FEL): instantiation and presence of `s1` method.
        *   Basic CCO schema compliance: presence of key fields like `cco_id`, `metadata_internal_cco`, `op_log_j`, `core_essence_j`, `initiating_document_s`.
    *   The results are returned in an `INFO_DIAGNOSTIC_REPORT` message.
    *   A summary of the last test is stored in `engine.sK` (Kernel state).

## 3. Setting up and Running an AIOS v6.0.1-mod5 Session

**3.1. Turn 1: Initial Setup:**
    1.  Provide entire `AIOS_Engine_v6.0.1-mod5.py` script.
        ```python
        # --- START OF AIOS_Engine_v6.0.1-mod5.py ---
        # (Paste entire content of AIOS_Engine_v6.0.1-mod5.py here)
        # --- END OF AIOS_Engine_v6.0.1-mod5.py ---

        # --- Orchestration for Turn 1 ---
        print("--- AIOS Engine v6.0.1-mod5 Init (Turn 1) ---")
        engine_instance_main = AIOSMainEngine_v6() 
        output_package_for_orchestrator = engine_instance_main.k_st()
        print(jsn.dumps(output_package_for_orchestrator, indent=2))
        print("--- AIOS Engine v6.0.1-mod5 Init End (Turn 1) ---")
        ```
    2.  Save `ces`.

**3.2. Subsequent Turns (Turns 2+):**
    *   (Same as `v6.0.1-mod4`) **Do NOT resend full class definitions.**
    *   Load engine with `ces`.
    *   Provide response/command.
    *   If engine previously sent `rd.aux_data_refs_passthrough`, ensure LLM gets that auxiliary data for the current cognitive task.

## 4. Reserved Commands
*   **NEW**: Starts IFE.
*   **EVOLVE**: Starts FEL.
*   **TEST**: Runs internal diagnostics and reports results.
*   Other commands (TERMINATE, STATUS, HELP, etc.) remain.

## 5. Engine Output (`A_LLM` Package)
*   If `CMD_TEST` is run, `tt` will be `INFO_DIAGNOSTIC_REPORT`, and `ctd` will contain the diagnostic results.
*   `rd` may contain `aux_data_refs_passthrough` for certain cognitive tasks.

This version provides a concrete self-diagnostic tool, fulfilling an evolution planned by FEL.
--- END OF FILE AIOS_User_Manual_v6.0.1-mod5.md ---

--- START OF FILE AIOS_v6.0.1-mod5_Implemented_TIDs.json ---
```json
[
  {
    "tid_id": "TID_CORE_MINIFY_001",
    "desc": "Codebase Minification for core engine and MHs.",
    "priority": "High",
    "status": "Maintained"
  },
  {
    "tid_id": "TID_PERF_002_LOG_HISTORY_EXPORT_OPTIMIZATION",
    "desc": "Optimize log history export in exs() to reduce state string size.",
    "priority": "High",
    "status": "Maintained"
  },
  {
    "tid_id": "TID_ARCH_002_MODULARIZE_ENGINE_V6",
    "desc": "Refactor monolithic engine script into collaborating classes.",
    "priority": "Critical",
    "status": "Maintained"
  },
  {
    "tid_id": "TID_KERNEL_CMD_HANDLING_V2",
    "desc": "Refine Kernel command handling for single-word reserved commands.",
    "priority": "High",
    "status": "Maintained and Evolved (v6.0.1-mod5 for CMD_TEST)"
  },
  {
    "tid_id": "TID_PROTOCOL_CH_REFINEMENT_V2",
    "desc": "Ensure Continuation Hints (ch) correctly point to AIOSMainEngine_v6 methods.",
    "priority": "High",
    "status": "Maintained"
  },
  {
    "tid_id": "TID_IFE_MODULAR_V1",
    "desc": "Implement full IFE Meta-Handler (s1-s4) as a modular class.",
    "priority": "High",
    "status": "Maintained (v6.0.1-mod5)"
  },
  {
    "tid_id": "TID_LOGGING_REFINED_V2",
    "desc": "Standardize logging mechanism.",
    "priority": "Medium",
    "status": "Maintained"
  },
  {
    "tid_id": "TID_PERF_003_CES_REDUCTION_LARGE_INPUTS",
    "desc": "Reduce CES size by not storing full large inputs verbatim in sI or CCO state.",
    "priority": "Critical",
    "status": "Maintained (v6.0.1-mod5)"
  },
  {
    "tid_id": "TID_IFE_INPUT_PROCESSING_V1",
    "desc": "IFE requests CT_PROCESS_INPUT_DOCUMENT to extract structured data from raw input. Store structured data in CCO, summary in sI. Use for drafting project core essence.",
    "priority": "High",
    "status": "Maintained (v6.0.1-mod5)"
  },
  {
    "tid_id": "TID_PROTOCOL_ORCH_DATA_FETCH_V1",
    "desc": "Define a mechanism in A_LLM requests (e.g., rd.aux_data_refs_passthrough) for the engine to specify if the orchestrator needs to provide auxiliary large data (by reference) to the LLM executing a cognitive task.",
    "priority": "High",
    "status": "Maintained (v6.0.1-mod5)"
  },
  {
    "tid_id": "TID_FEL_BASIC_SCAFFOLD_V1",
    "desc": "Implement basic scaffolding for AIOS_MH_FEL_v6 (s1: elicit goal, s2: request CT_PLAN_AIOS_EVOLUTION, s3: store plan in CCO).",
    "priority": "High",
    "status": "Maintained (v6.0.1-mod5)"
  },
  {
    "tid_id": "TID_KERNEL_CMD_TEST_V1",
    "desc": "Implement CMD_TEST handler in AIOSKernel_v6.k_rcmh to invoke a new diagnostic routine in AIOSMainEngine_v6.",
    "priority": "High",
    "status": "Implemented (v6.0.1-mod5)"
  },
  {
    "tid_id": "TID_DIAGNOSTIC_ROUTINE_V1",
    "desc": "Create _run_diagnostics method in AIOSMainEngine_v6 for CMD_TEST. Checks MH integrity (instantiation, s1 method) and basic CCO schema compliance (key elements).",
    "priority": "High",
    "status": "Implemented (v6.0.1-mod5)"
  }
]
```
--- END OF FILE AIOS_v6.0.1-mod5_Implemented_TIDs.json ---

--- START OF FILE README_AIOS_v6.0.1-mod5.md ---
# AIOS Engine v6.0.1-mod5

**Version:** `6.0.1-mod5`
**Date:** [Current Date]

## Overview

`AIOS_Engine_v6.0.1-mod5.py` implements the `CMD_TEST` functionality that was conceptually designed by the Framework Evolution Lab (FEL) in the previous simulated iteration (`v6.0.1-mod4`). This new command allows users to run a basic set of internal diagnostics on the AIOS engine, checking the integrity of its Meta-Handlers (MHs) and the basic schema of the active Conceptual Core Object (CCO).

This version demonstrates a complete conceptual cycle of AIOS self-evolution:
1.  Identifying a need (for a test/diagnostic function).
2.  Using FEL to plan the implementation of this function (resulting in TIDs).
3.  (Conceptually) Implementing those TIDs to create this new version.

## Key Features of v6.0.1-mod5:

*   **`CMD_TEST` Implemented:**
    *   The `TEST` command is now a recognized system command.
    *   It triggers a new diagnostic routine (`_run_diagnostics` in `AIOSMainEngine_v6`).
    *   **Diagnostics Performed:**
        *   **MH Integrity:** Checks if registered MHs (currently IFE and FEL) can be instantiated and have a callable `s1` method.
        *   **CCO Schema (Basic):** If a CCO is loaded, it verifies the presence of essential top-level keys (`cco_id`, `metadata_internal_cco`, `op_log_j`, etc.) and some nested keys within `metadata_internal_cco`.
    *   The results are returned to the user in an `INFO_DIAGNOSTIC_REPORT` message.
    *   A brief summary of the last test (timestamp, status) is stored in the engine's kernel state (`sK`).
*   **Updated User Prompts:** The AUI prompt and initial command options now include "TEST".
*   **Maintains Previous Enhancements:** Retains efficient state management, intelligent input processing (IFE), FEL scaffolding, and the auxiliary data request protocol from `v6.0.1-mod4`.

## Package Contents:

*   `AIOS_Engine_v6.0.1-mod5.py`: The runnable engine script.
*   `AIOS_User_Manual_v6.0.1-mod5.md`: Detailed usage instructions.
*   `AIOS_v6.0.1-mod5_ChangeLog.md`: Log of changes for this version.
*   `AIOS_v6.0.1-mod5_Implemented_TIDs.json`: List of TIDs addressed.
*   `README_AIOS_v6.0.1-mod5.md` (This file).

## How to Run:

1.  **Turn 1 (Initial Setup):**
    *   Provide the **entire content of `AIOS_Engine_v6.0.1-mod5.py`** in the `tool_code` block, followed by the orchestration snippet to start.
2.  **Subsequent Turns:**
    *   **Crucial Orchestrator Behavior:**
        *   **Do NOT resend the full Python class definitions** if your environment persists them.
        *   Handle `aux_data_refs_passthrough` if present in the engine's output.
    *   Load the engine with `ces` from the previous turn.
    *   Provide the appropriate response object (user input or cognitive task result) to the method specified in the previous turn's `ch`.

Refer to `AIOS_User_Manual_v6.0.1-mod5.md` for detailed operational procedures.
--- END OF FILE README_AIOS_v6.0.1-mod5.md ---

